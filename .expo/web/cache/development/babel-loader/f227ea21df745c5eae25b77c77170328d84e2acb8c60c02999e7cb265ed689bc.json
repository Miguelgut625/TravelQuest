{"ast":null,"code":"import * as Notifications from 'expo-notifications';\nimport { supabase } from './supabase';\nimport { sendPushNotification } from './notificationsService';\nexport const scheduleMissionReminders = async missions => {\n  for (const mission of missions) {\n    const endDate = new Date(mission.endDate);\n    const now = new Date();\n    const timeUntilEnd = endDate.getTime() - now.getTime();\n    if (timeUntilEnd <= 0) continue;\n    const reminderTime = new Date(endDate.getTime() - 24 * 60 * 60 * 1000);\n    if (reminderTime > now) {\n      await Notifications.scheduleNotificationAsync({\n        content: {\n          title: '¡Misión Pendiente!',\n          body: `No olvides completar la misión \"${mission.title}\" antes de que expire.`,\n          data: {\n            missionId: mission.missionId,\n            type: 'mission_reminder'\n          }\n        },\n        trigger: {\n          date: reminderTime\n        }\n      });\n    }\n    const lastReminderTime = new Date(endDate.getTime() - 60 * 60 * 1000);\n    if (lastReminderTime > now) {\n      await Notifications.scheduleNotificationAsync({\n        content: {\n          title: '¡Misión a punto de expirar!',\n          body: `La misión \"${mission.title}\" expirará en 1 hora. ¡Date prisa!`,\n          data: {\n            missionId: mission.missionId,\n            type: 'mission_expiring'\n          }\n        },\n        trigger: {\n          date: lastReminderTime\n        }\n      });\n    }\n  }\n};\nexport const sendJourneySharedNotification = async (receiverId, senderUsername, journeyTitle) => {\n  try {\n    console.log('Intentando enviar notificación de viaje compartido:', {\n      receiverId,\n      senderUsername,\n      journeyTitle\n    });\n    const {\n      data: userData,\n      error: userError\n    } = await supabase.from('users').select('id').eq('id', receiverId).single();\n    if (userError) {\n      console.error('Error verificando usuario:', userError);\n      throw userError;\n    }\n    if (!userData) {\n      console.error('Usuario no encontrado:', receiverId);\n      throw new Error('Usuario no encontrado');\n    }\n    const {\n      data: notificationData,\n      error: notificationError\n    } = await supabase.from('notifications').insert({\n      user_id: receiverId,\n      title: '¡Nuevo Viaje Compartido!',\n      message: `${senderUsername} ha compartido el viaje \"${journeyTitle}\" contigo.`,\n      type: 'journey_shared',\n      read: false,\n      data: {\n        journeyTitle\n      },\n      created_at: new Date().toISOString()\n    }).select();\n    if (notificationError) {\n      console.error('Error creando notificación:', notificationError);\n      throw notificationError;\n    }\n    console.log('Notificación creada exitosamente:', notificationData);\n    await sendPushNotification(receiverId, '¡Nuevo Viaje Compartido!', `${senderUsername} ha compartido el viaje \"${journeyTitle}\" contigo.`);\n    console.log('Notificación push enviada exitosamente');\n  } catch (error) {\n    console.error('Error enviando notificación de viaje compartido:', error);\n    throw error;\n  }\n};\nexport const checkAndScheduleExpiringMissions = async userId => {\n  try {\n    const {\n      data: missions,\n      error\n    } = await supabase.from('journeys_missions').select(`\n        id,\n        completed,\n        end_date,\n        challenges (\n          title\n        )\n      `).eq('completed', false).gt('end_date', new Date().toISOString());\n    if (error) throw error;\n    if (missions) {\n      const missionReminders = missions.map(mission => ({\n        missionId: mission.id,\n        title: mission.challenges.title,\n        endDate: mission.end_date,\n        userId: userId\n      }));\n      await scheduleMissionReminders(missionReminders);\n    }\n  } catch (error) {\n    console.error('Error verificando misiones a punto de expirar:', error);\n  }\n};","map":{"version":3,"names":["Notifications","supabase","sendPushNotification","scheduleMissionReminders","missions","mission","endDate","Date","now","timeUntilEnd","getTime","reminderTime","scheduleNotificationAsync","content","title","body","data","missionId","type","trigger","date","lastReminderTime","sendJourneySharedNotification","receiverId","senderUsername","journeyTitle","console","log","userData","error","userError","from","select","eq","single","Error","notificationData","notificationError","insert","user_id","message","read","created_at","toISOString","checkAndScheduleExpiringMissions","userId","gt","missionReminders","map","id","challenges","end_date"],"sources":["C:/Users/PC/TravelQuest/src/services/notificationTriggers.ts"],"sourcesContent":["import * as Notifications from 'expo-notifications';\r\nimport { supabase } from './supabase';\r\nimport { sendPushNotification } from './notificationsService';\r\n\r\ninterface MissionReminder {\r\n    missionId: string;\r\n    title: string;\r\n    endDate: string;\r\n    userId: string;\r\n}\r\n\r\n/**\r\n * Programa recordatorios para misiones pendientes\r\n * @param missions Lista de misiones pendientes\r\n */\r\nexport const scheduleMissionReminders = async (missions: MissionReminder[]) => {\r\n    for (const mission of missions) {\r\n        const endDate = new Date(mission.endDate);\r\n        const now = new Date();\r\n        const timeUntilEnd = endDate.getTime() - now.getTime();\r\n\r\n        // Si la misión ya expiró, no programamos recordatorio\r\n        if (timeUntilEnd <= 0) continue;\r\n\r\n        // Programar notificación para 24 horas antes de que expire\r\n        const reminderTime = new Date(endDate.getTime() - 24 * 60 * 60 * 1000);\r\n\r\n        if (reminderTime > now) {\r\n            await Notifications.scheduleNotificationAsync({\r\n                content: {\r\n                    title: '¡Misión Pendiente!',\r\n                    body: `No olvides completar la misión \"${mission.title}\" antes de que expire.`,\r\n                    data: { missionId: mission.missionId, type: 'mission_reminder' },\r\n                },\r\n                trigger: {\r\n                    date: reminderTime,\r\n                },\r\n            });\r\n        }\r\n\r\n        // Programar notificación para 1 hora antes de que expire\r\n        const lastReminderTime = new Date(endDate.getTime() - 60 * 60 * 1000);\r\n\r\n        if (lastReminderTime > now) {\r\n            await Notifications.scheduleNotificationAsync({\r\n                content: {\r\n                    title: '¡Misión a punto de expirar!',\r\n                    body: `La misión \"${mission.title}\" expirará en 1 hora. ¡Date prisa!`,\r\n                    data: { missionId: mission.missionId, type: 'mission_expiring' },\r\n                },\r\n                trigger: {\r\n                    date: lastReminderTime,\r\n                },\r\n            });\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Envía notificación cuando un amigo comparte un viaje\r\n * @param receiverId ID del usuario que recibe el viaje compartido\r\n * @param senderUsername Nombre del usuario que comparte el viaje\r\n * @param journeyTitle Título del viaje compartido\r\n */\r\nexport const sendJourneySharedNotification = async (\r\n    receiverId: string,\r\n    senderUsername: string,\r\n    journeyTitle: string\r\n) => {\r\n    try {\r\n        console.log('Intentando enviar notificación de viaje compartido:', {\r\n            receiverId,\r\n            senderUsername,\r\n            journeyTitle\r\n        });\r\n\r\n        // Verificar que el usuario existe\r\n        const { data: userData, error: userError } = await supabase\r\n            .from('users')\r\n            .select('id')\r\n            .eq('id', receiverId)\r\n            .single();\r\n\r\n        if (userError) {\r\n            console.error('Error verificando usuario:', userError);\r\n            throw userError;\r\n        }\r\n\r\n        if (!userData) {\r\n            console.error('Usuario no encontrado:', receiverId);\r\n            throw new Error('Usuario no encontrado');\r\n        }\r\n\r\n        // Crear registro en la tabla notifications\r\n        const { data: notificationData, error: notificationError } = await supabase\r\n            .from('notifications')\r\n            .insert({\r\n                user_id: receiverId,\r\n                title: '¡Nuevo Viaje Compartido!',\r\n                message: `${senderUsername} ha compartido el viaje \"${journeyTitle}\" contigo.`,\r\n                type: 'journey_shared',\r\n                read: false,\r\n                data: { journeyTitle },\r\n                created_at: new Date().toISOString()\r\n            })\r\n            .select();\r\n\r\n        if (notificationError) {\r\n            console.error('Error creando notificación:', notificationError);\r\n            throw notificationError;\r\n        }\r\n\r\n        console.log('Notificación creada exitosamente:', notificationData);\r\n\r\n        // Enviar notificación push\r\n        await sendPushNotification(\r\n            receiverId,\r\n            '¡Nuevo Viaje Compartido!',\r\n            `${senderUsername} ha compartido el viaje \"${journeyTitle}\" contigo.`\r\n        );\r\n\r\n        console.log('Notificación push enviada exitosamente');\r\n    } catch (error) {\r\n        console.error('Error enviando notificación de viaje compartido:', error);\r\n        throw error;\r\n    }\r\n};\r\n\r\n/**\r\n * Verifica y programa notificaciones para misiones que están a punto de expirar\r\n * @param userId ID del usuario\r\n */\r\nexport const checkAndScheduleExpiringMissions = async (userId: string) => {\r\n    try {\r\n        // Obtener misiones pendientes del usuario\r\n        const { data: missions, error } = await supabase\r\n            .from('journeys_missions')\r\n            .select(`\r\n        id,\r\n        completed,\r\n        end_date,\r\n        challenges (\r\n          title\r\n        )\r\n      `)\r\n            .eq('completed', false)\r\n            .gt('end_date', new Date().toISOString());\r\n\r\n        if (error) throw error;\r\n\r\n        if (missions) {\r\n            const missionReminders: MissionReminder[] = missions.map(mission => ({\r\n                missionId: mission.id,\r\n                title: mission.challenges.title,\r\n                endDate: mission.end_date,\r\n                userId: userId\r\n            }));\r\n\r\n            await scheduleMissionReminders(missionReminders);\r\n        }\r\n    } catch (error) {\r\n        console.error('Error verificando misiones a punto de expirar:', error);\r\n    }\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}