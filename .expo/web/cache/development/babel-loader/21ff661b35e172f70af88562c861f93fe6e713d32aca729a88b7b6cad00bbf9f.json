{"ast":null,"code":"import * as Notifications from 'expo-notifications';\nimport * as Device from 'expo-device';\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport { supabase } from './supabase';\nexport class NotificationService {\n  static async registerForPushNotificationsAsync() {\n    let token;\n    if (Platform.OS === 'android') {\n      await Notifications.setNotificationChannelAsync('default', {\n        name: 'default',\n        importance: Notifications.AndroidImportance.MAX,\n        vibrationPattern: [0, 250, 250, 250],\n        lightColor: '#FF231F7C'\n      });\n    }\n    if (Device.isDevice) {\n      const {\n        status: existingStatus\n      } = await Notifications.getPermissionsAsync();\n      let finalStatus = existingStatus;\n      if (existingStatus !== 'granted') {\n        const {\n          status\n        } = await Notifications.requestPermissionsAsync();\n        finalStatus = status;\n      }\n      if (finalStatus !== 'granted') {\n        console.log('Failed to get push token for push notification!');\n        return;\n      }\n      token = (await Notifications.getExpoPushTokenAsync()).data;\n      const {\n        data: {\n          user\n        }\n      } = await supabase.auth.getUser();\n      if (user) {\n        try {\n          const deviceId = await Device.getDeviceTypeAsync();\n          const {\n            data,\n            error\n          } = await supabase.from('user_push_tokens').upsert({\n            user_id: user.id,\n            token: token,\n            device_id: deviceId.toString(),\n            platform: Platform.OS\n          }, {\n            onConflict: 'user_id,token'\n          }).select().single();\n          if (error) {\n            console.error('Error saving push token:', error);\n            throw error;\n          } else {\n            console.log('Push token saved successfully:', data);\n            return data;\n          }\n        } catch (error) {\n          console.error('Error in savePushToken:', error);\n          throw error;\n        }\n      }\n    } else {\n      console.log('Must use physical device for Push Notifications');\n    }\n    return token;\n  }\n  static async createNotification(userId, title, message, type, data) {\n    try {\n      const {\n        data: notification,\n        error\n      } = await supabase.from('notifications').insert({\n        userid: userId,\n        title,\n        message,\n        type,\n        data,\n        read: false\n      }).select().single();\n      if (error) throw error;\n      return notification;\n    } catch (error) {\n      console.error('Error creating notification:', error);\n      throw error;\n    }\n  }\n  static async getUnreadNotifications(userId) {\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from('notifications').select('*').eq('userid', userId).eq('read', false).order('created_at', {\n        ascending: false\n      });\n      if (error) throw error;\n      return data;\n    } catch (error) {\n      console.error('Error getting unread notifications:', error);\n      throw error;\n    }\n  }\n  static async markNotificationAsRead(notificationId) {\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from('notifications').update({\n        read: true\n      }).eq('id', notificationId).select().single();\n      if (error) throw error;\n      return data;\n    } catch (error) {\n      console.error('Error marking notification as read:', error);\n      throw error;\n    }\n  }\n  static async scheduleNotification(title, body, data = {}) {\n    await Notifications.scheduleNotificationAsync({\n      content: {\n        title,\n        body,\n        data\n      },\n      trigger: null\n    });\n  }\n}","map":{"version":3,"names":["Notifications","Device","Platform","supabase","NotificationService","registerForPushNotificationsAsync","token","OS","setNotificationChannelAsync","name","importance","AndroidImportance","MAX","vibrationPattern","lightColor","isDevice","status","existingStatus","getPermissionsAsync","finalStatus","requestPermissionsAsync","console","log","getExpoPushTokenAsync","data","user","auth","getUser","deviceId","getDeviceTypeAsync","error","from","upsert","user_id","id","device_id","toString","platform","onConflict","select","single","createNotification","userId","title","message","type","notification","insert","userid","read","getUnreadNotifications","eq","order","ascending","markNotificationAsRead","notificationId","update","scheduleNotification","body","scheduleNotificationAsync","content","trigger"],"sources":["C:/Users/PC/TravelQuest/src/services/NotificationService.ts"],"sourcesContent":["import * as Notifications from 'expo-notifications';\nimport * as Device from 'expo-device';\nimport { Platform } from 'react-native';\nimport { supabase } from './supabase';\nimport { Notification, PushToken } from '../types/notifications';\n\nexport class NotificationService {\n    static async registerForPushNotificationsAsync() {\n        let token;\n\n        if (Platform.OS === 'android') {\n            await Notifications.setNotificationChannelAsync('default', {\n                name: 'default',\n                importance: Notifications.AndroidImportance.MAX,\n                vibrationPattern: [0, 250, 250, 250],\n                lightColor: '#FF231F7C',\n            });\n        }\n\n        if (Device.isDevice) {\n            const { status: existingStatus } = await Notifications.getPermissionsAsync();\n            let finalStatus = existingStatus;\n\n            if (existingStatus !== 'granted') {\n                const { status } = await Notifications.requestPermissionsAsync();\n                finalStatus = status;\n            }\n\n            if (finalStatus !== 'granted') {\n                console.log('Failed to get push token for push notification!');\n                return;\n            }\n\n            token = (await Notifications.getExpoPushTokenAsync()).data;\n\n            // Guardar el token en Supabase\n            const { data: { user } } = await supabase.auth.getUser();\n            if (user) {\n                try {\n                    const deviceId = await Device.getDeviceTypeAsync();\n                    const { data, error } = await supabase\n                        .from('user_push_tokens')\n                        .upsert({\n                            user_id: user.id,\n                            token: token,\n                            device_id: deviceId.toString(),\n                            platform: Platform.OS\n                        }, {\n                            onConflict: 'user_id,token'\n                        })\n                        .select()\n                        .single();\n\n                    if (error) {\n                        console.error('Error saving push token:', error);\n                        throw error;\n                    } else {\n                        console.log('Push token saved successfully:', data);\n                        return data as PushToken;\n                    }\n                } catch (error) {\n                    console.error('Error in savePushToken:', error);\n                    throw error;\n                }\n            }\n        } else {\n            console.log('Must use physical device for Push Notifications');\n        }\n\n        return token;\n    }\n\n    static async createNotification(userId: string, title: string, message: string, type: string, data?: any): Promise<Notification> {\n        try {\n            const { data: notification, error } = await supabase\n                .from('notifications')\n                .insert({\n                    userid: userId,\n                    title,\n                    message,\n                    type,\n                    data,\n                    read: false\n                })\n                .select()\n                .single();\n\n            if (error) throw error;\n            return notification as Notification;\n        } catch (error) {\n            console.error('Error creating notification:', error);\n            throw error;\n        }\n    }\n\n    static async getUnreadNotifications(userId: string): Promise<Notification[]> {\n        try {\n            const { data, error } = await supabase\n                .from('notifications')\n                .select('*')\n                .eq('userid', userId)\n                .eq('read', false)\n                .order('created_at', { ascending: false });\n\n            if (error) throw error;\n            return data as Notification[];\n        } catch (error) {\n            console.error('Error getting unread notifications:', error);\n            throw error;\n        }\n    }\n\n    static async markNotificationAsRead(notificationId: string): Promise<Notification> {\n        try {\n            const { data, error } = await supabase\n                .from('notifications')\n                .update({ read: true })\n                .eq('id', notificationId)\n                .select()\n                .single();\n\n            if (error) throw error;\n            return data as Notification;\n        } catch (error) {\n            console.error('Error marking notification as read:', error);\n            throw error;\n        }\n    }\n\n    static async scheduleNotification(title: string, body: string, data: any = {}) {\n        await Notifications.scheduleNotificationAsync({\n            content: {\n                title,\n                body,\n                data,\n            },\n            trigger: null,\n        });\n    }\n} "],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}