{"ast":null,"code":"import { supabase } from \"./supabase\";\nconst {\n  GoogleGenerativeAI\n} = require(\"@google/generative-ai\");\nconst genAI = new GoogleGenerativeAI(\"AIzaSyB4PuDOYXgbH9egme1UCO0CiRcOV4kVfMM\");\nconst getOrCreateUser = async userId => {\n  try {\n    const {\n      data: existingUser,\n      error: searchError\n    } = await supabase.from('users').select('id').eq('id', userId).single();\n    if (searchError && searchError.code !== 'PGRST116') {\n      throw searchError;\n    }\n    if (existingUser) {\n      return existingUser.id;\n    }\n    const {\n      data: newUser,\n      error: insertError\n    } = await supabase.from('users').insert([{\n      id: userId,\n      email: `${userId}@temp.com`,\n      username: `user_${userId.slice(0, 8)}`,\n      password: 'temp_password'\n    }]).select('id').single();\n    if (insertError) throw insertError;\n    return newUser.id;\n  } catch (error) {\n    console.error('Error al obtener/crear el usuario:', error);\n    throw error;\n  }\n};\nconst getOrCreateCity = async cityName => {\n  try {\n    const {\n      data: existingCity,\n      error: searchError\n    } = await supabase.from('cities').select('id').eq('name', cityName).single();\n    if (searchError && searchError.code !== 'PGRST116') {\n      throw searchError;\n    }\n    if (existingCity) {\n      return existingCity.id;\n    }\n    const {\n      data: newCity,\n      error: insertError\n    } = await supabase.from('cities').insert([{\n      name: cityName\n    }]).select('id').single();\n    if (insertError) throw insertError;\n    return newCity.id;\n  } catch (error) {\n    console.error('Error al obtener/crear la ciudad:', error);\n    throw error;\n  }\n};\nconst getExistingChallenges = async (cityId, count, userId) => {\n  try {\n    const {\n      data: challenges,\n      error\n    } = await supabase.from('challenges').select('*').eq('cityId', cityId);\n    if (error) throw error;\n    if (!challenges || challenges.length === 0) {\n      return null;\n    }\n    const {\n      data: userJourneys,\n      error: journeysError\n    } = await supabase.from('journeys').select('id').eq('userId', userId);\n    if (journeysError) throw journeysError;\n    if (!userJourneys || userJourneys.length === 0) {\n      if (challenges.length >= 10) {\n        const shuffled = challenges.sort(() => 0.5 - Math.random());\n        return shuffled.slice(0, count);\n      }\n      return null;\n    }\n    const {\n      data: userChallenges,\n      error: userError\n    } = await supabase.from('journeys_missions').select('challengeId').in('journeyId', userJourneys.map(j => j.id)).in('challengeId', challenges.map(c => c.id));\n    if (userError) throw userError;\n    const userChallengeIds = new Set(userChallenges?.map(uc => uc.challengeId) || []);\n    const availableChallenges = challenges.filter(c => !userChallengeIds.has(c.id));\n    if (availableChallenges.length >= 10) {\n      const shuffled = availableChallenges.sort(() => 0.5 - Math.random());\n      return shuffled.slice(0, count);\n    }\n    return null;\n  } catch (error) {\n    console.error('Error obteniendo desafíos existentes:', error);\n    throw error;\n  }\n};\nconst generateMission = async (cityName, duration, missionCount, userId) => {\n  try {\n    console.log('Iniciando generación de misión:', {\n      cityName,\n      duration,\n      missionCount,\n      userId\n    });\n    await getOrCreateUser(userId);\n    const cityId = await getOrCreateCity(cityName);\n    console.log('CityId obtenido/creado:', cityId);\n    const {\n      data: journey,\n      error: journeyError\n    } = await supabase.from('journeys').insert([{\n      userId,\n      cityId,\n      description: `Viaje a ${cityName} por ${duration} días`,\n      created_at: new Date().toISOString()\n    }]).select('id').single();\n    if (journeyError) {\n      console.error('Error creando journey:', journeyError);\n      throw journeyError;\n    }\n    console.log('Journey creado:', journey);\n    const existingChallenges = await getExistingChallenges(cityId, missionCount, userId);\n    console.log('Desafíos existentes encontrados:', existingChallenges);\n    let challenges;\n    if (existingChallenges && existingChallenges.length > 0) {\n      console.log('Usando desafíos existentes');\n      challenges = existingChallenges;\n    } else {\n      console.log('Generando nuevos desafíos');\n      const model = genAI.getGenerativeModel({\n        model: \"gemini-1.5-flash\"\n      });\n      const prompt = `Genera ${missionCount} misiones en ${cityName} que se puedan completar en ${duration} días. Devuelve un objeto JSON con la siguiente estructura exacta:\n{\n  \"misiones\": [\n    {\n      \"Título\": \"Título de la misión\",\n      \"Descripción\": \"Descripción detallada de la misión incluyendo qué foto tomar\",\n      \"Dificultad\": \"Fácil|Media|Difícil\",\n      \"Puntos\": 25|50|100\n    }\n  ]\n}\nLos puntos deben ser: 25 para Fácil, 50 para Media, 100 para Difícil. No incluyas explicaciones adicionales, solo el JSON.`;\n      const result = await model.generateContent(prompt);\n      const response = await result.response;\n      const missionsData = response.text();\n      console.log('Respuesta de la API:', missionsData);\n      const jsonMatch = missionsData.match(/\\{[\\s\\S]*\\}/);\n      if (!jsonMatch) {\n        throw new Error('No se encontró un objeto JSON válido en la respuesta');\n      }\n      const missions = JSON.parse(jsonMatch[0]);\n      if (!missions.misiones || !Array.isArray(missions.misiones)) {\n        throw new Error('La respuesta no contiene un array de misiones válido');\n      }\n      const formattedChallenges = missions.misiones.map(mission => ({\n        title: mission.Título,\n        description: mission.Descripción,\n        cityId,\n        duration,\n        difficulty: mission.Dificultad,\n        points: mission.Puntos\n      }));\n      const {\n        data: newChallenges,\n        error: challengesError\n      } = await supabase.from('challenges').insert(formattedChallenges).select('id');\n      if (challengesError) throw challengesError;\n      challenges = newChallenges;\n    }\n    const journeyMissions = challenges.map(challenge => ({\n      journeyId: journey.id,\n      challengeId: challenge.id,\n      completed: false,\n      created_at: new Date().toISOString()\n    }));\n    console.log('Vincular misiones al journey:', journeyMissions);\n    const {\n      error: linkError\n    } = await supabase.from('journeys_missions').insert(journeyMissions);\n    if (linkError) {\n      console.error('Error vinculando misiones:', linkError);\n      throw linkError;\n    }\n    const {\n      data: createdMissions,\n      error: verifyError\n    } = await supabase.from('journeys_missions').select(`\n        id,\n        challengeId,\n        completed,\n        challenge:challenges (\n        title,\n        description,\n        difficulty,\n          points\n        )\n      `).eq('journeyId', journey.id).order('created_at', {\n      ascending: true\n    });\n    if (verifyError) {\n      console.error('Error verificando misiones creadas:', verifyError);\n      throw verifyError;\n    }\n    if (!createdMissions || createdMissions.length === 0) {\n      throw new Error('No se pudieron crear las misiones');\n    }\n    console.log('Misiones creadas verificadas:', createdMissions);\n    return {\n      journeyId: journey.id,\n      challenges: createdMissions\n    };\n  } catch (error) {\n    console.error('Error generando desafíos:', error);\n    throw error;\n  }\n};\nexport default generateMission;","map":{"version":3,"names":["supabase","GoogleGenerativeAI","require","genAI","getOrCreateUser","userId","data","existingUser","error","searchError","from","select","eq","single","code","id","newUser","insertError","insert","email","username","slice","password","console","getOrCreateCity","cityName","existingCity","newCity","name","getExistingChallenges","cityId","count","challenges","length","userJourneys","journeysError","shuffled","sort","Math","random","userChallenges","userError","in","map","j","c","userChallengeIds","Set","uc","challengeId","availableChallenges","filter","has","generateMission","duration","missionCount","log","journey","journeyError","description","created_at","Date","toISOString","existingChallenges","model","getGenerativeModel","prompt","result","generateContent","response","missionsData","text","jsonMatch","match","Error","missions","JSON","parse","misiones","Array","isArray","formattedChallenges","mission","title","Título","Descripción","difficulty","Dificultad","points","Puntos","newChallenges","challengesError","journeyMissions","challenge","journeyId","completed","linkError","createdMissions","verifyError","order","ascending"],"sources":["C:/Users/PC/TravelQuest/src/services/missionGenerator.ts"],"sourcesContent":["import { supabase } from './supabase';\nconst { GoogleGenerativeAI } = require(\"@google/generative-ai\");\n\n// Accede a tu clave de API como una variable de entorno\nconst genAI = new GoogleGenerativeAI(\"AIzaSyB4PuDOYXgbH9egme1UCO0CiRcOV4kVfMM\");\n\n// Interfaces para los tipos de datos\ninterface Challenge {\n  id: string;\n}\n\ninterface UserChallenge {\n  challengeId: string;\n}\n\ninterface Journey {\n  id: string;\n}\n\n// Función para verificar y crear usuario si no existe\nconst getOrCreateUser = async (userId: string) => {\n  try {\n    // Verificar si el usuario existe\n    const { data: existingUser, error: searchError } = await supabase\n      .from('users')\n      .select('id')\n      .eq('id', userId)\n      .single();\n\n    if (searchError && searchError.code !== 'PGRST116') {\n      throw searchError;\n    }\n\n    if (existingUser) {\n      return existingUser.id;\n    }\n\n    // Si no existe, crear el usuario\n    const { data: newUser, error: insertError } = await supabase\n      .from('users')\n      .insert([{\n        id: userId,\n        email: `${userId}@temp.com`, // Email temporal\n        username: `user_${userId.slice(0, 8)}`, // Username temporal\n        password: 'temp_password' // Contraseña temporal\n      }])\n      .select('id')\n      .single();\n\n    if (insertError) throw insertError;\n\n    return newUser.id;\n  } catch (error) {\n    console.error('Error al obtener/crear el usuario:', error);\n    throw error;\n  }\n};\n\n// Función para obtener o crear una ciudad\nconst getOrCreateCity = async (cityName: string) => {\n  try {\n    // Primero intentamos encontrar la ciudad\n    const { data: existingCity, error: searchError } = await supabase\n      .from('cities')\n      .select('id')\n      .eq('name', cityName)\n      .single();\n\n    if (searchError && searchError.code !== 'PGRST116') { // PGRST116 es el código para \"no se encontraron resultados\"\n      throw searchError;\n    }\n\n    if (existingCity) {\n      return existingCity.id;\n    }\n\n    // Si no existe la ciudad, la creamos\n    const { data: newCity, error: insertError } = await supabase\n      .from('cities')\n      .insert([{ name: cityName }])\n      .select('id')\n      .single();\n\n    if (insertError) throw insertError;\n\n    return newCity.id;\n  } catch (error) {\n    console.error('Error al obtener/crear la ciudad:', error);\n    throw error;\n  }\n};\n\n// Función para obtener desafíos existentes de una ciudad que el usuario no haya solicitado\nconst getExistingChallenges = async (cityId: string, count: number, userId: string) => {\n  try {\n    // Primero obtenemos todos los desafíos de la ciudad\n    const { data: challenges, error } = await supabase\n      .from('challenges')\n      .select('*') // Seleccionar todos los campos, no solo el id\n      .eq('cityId', cityId);\n\n    if (error) throw error;\n\n    if (!challenges || challenges.length === 0) {\n      return null;\n    }\n\n    // Obtener los desafíos que el usuario ya ha solicitado\n    // Primero obtenemos los journeys del usuario\n    const { data: userJourneys, error: journeysError } = await supabase\n      .from('journeys')\n      .select('id')\n      .eq('userId', userId);\n\n    if (journeysError) throw journeysError;\n\n    if (!userJourneys || userJourneys.length === 0) {\n      // Si el usuario no tiene journeys, seleccionar aleatoriamente la cantidad solicitada\n      if (challenges.length >= 10) {\n        const shuffled = challenges.sort(() => 0.5 - Math.random());\n        return shuffled.slice(0, count);\n      }\n      return null;\n    }\n\n    // Luego obtenemos los desafíos asociados a esos journeys\n    const { data: userChallenges, error: userError } = await supabase\n      .from('journeys_missions')\n      .select('challengeId')\n      .in('journeyId', userJourneys.map((j: Journey) => j.id))\n      .in('challengeId', challenges.map((c: Challenge) => c.id));\n\n    if (userError) throw userError;\n\n    // Filtrar los desafíos que el usuario ya ha solicitado\n    const userChallengeIds = new Set(userChallenges?.map((uc: UserChallenge) => uc.challengeId) || []);\n    const availableChallenges = challenges.filter((c: Challenge) => !userChallengeIds.has(c.id));\n\n    // Si hay suficientes desafíos disponibles (10 o más)\n    if (availableChallenges.length >= 10) {\n      // Mezclar el array de desafíos disponibles\n      const shuffled = availableChallenges.sort(() => 0.5 - Math.random());\n      // Tomar solo la cantidad solicitada\n      return shuffled.slice(0, count);\n    }\n\n    return null; // Retornar null si no hay suficientes desafíos disponibles\n  } catch (error) {\n    console.error('Error obteniendo desafíos existentes:', error);\n    throw error;\n  }\n};\n\nconst generateMission = async (cityName: string, duration: number, missionCount: number, userId: string) => {\n  try {\n    console.log('Iniciando generación de misión:', { cityName, duration, missionCount, userId });\n\n    // Verificar y crear usuario si no existe\n    await getOrCreateUser(userId);\n\n    // Obtener o crear la ciudad\n    const cityId = await getOrCreateCity(cityName);\n    console.log('CityId obtenido/creado:', cityId);\n\n    // Crear un nuevo journey\n    const { data: journey, error: journeyError } = await supabase\n      .from('journeys')\n      .insert([{\n        userId,\n        cityId,\n        description: `Viaje a ${cityName} por ${duration} días`,\n        created_at: new Date().toISOString()\n      }])\n      .select('id')\n      .single();\n\n    if (journeyError) {\n      console.error('Error creando journey:', journeyError);\n      throw journeyError;\n    }\n\n    console.log('Journey creado:', journey);\n\n    // Verificar si hay suficientes desafíos existentes que el usuario no haya solicitado\n    const existingChallenges = await getExistingChallenges(cityId, missionCount, userId);\n    console.log('Desafíos existentes encontrados:', existingChallenges);\n\n    let challenges;\n    if (existingChallenges && existingChallenges.length > 0) {\n      // Usar desafíos existentes\n      console.log('Usando desafíos existentes');\n      challenges = existingChallenges;\n    } else {\n      // Solo generar nuevos desafíos si no hay suficientes existentes\n      console.log('Generando nuevos desafíos');\n      // Generar nuevos desafíos\n      const model = genAI.getGenerativeModel({ model: \"gemini-1.5-flash\" });\n\n      const prompt = `Genera ${missionCount} misiones en ${cityName} que se puedan completar en ${duration} días. Devuelve un objeto JSON con la siguiente estructura exacta:\n{\n  \"misiones\": [\n    {\n      \"Título\": \"Título de la misión\",\n      \"Descripción\": \"Descripción detallada de la misión incluyendo qué foto tomar\",\n      \"Dificultad\": \"Fácil|Media|Difícil\",\n      \"Puntos\": 25|50|100\n    }\n  ]\n}\nLos puntos deben ser: 25 para Fácil, 50 para Media, 100 para Difícil. No incluyas explicaciones adicionales, solo el JSON.`;\n\n      const result = await model.generateContent(prompt);\n      const response = await result.response;\n      const missionsData = response.text();\n\n      console.log('Respuesta de la API:', missionsData);\n\n      const jsonMatch = missionsData.match(/\\{[\\s\\S]*\\}/);\n      if (!jsonMatch) {\n        throw new Error('No se encontró un objeto JSON válido en la respuesta');\n      }\n\n      const missions = JSON.parse(jsonMatch[0]);\n\n      if (!missions.misiones || !Array.isArray(missions.misiones)) {\n        throw new Error('La respuesta no contiene un array de misiones válido');\n      }\n\n      // Crear los desafíos\n      const formattedChallenges = missions.misiones.map((mission: any) => ({\n        title: mission.Título,\n        description: mission.Descripción,\n        cityId,\n        duration,\n        difficulty: mission.Dificultad,\n        points: mission.Puntos\n      }));\n\n      const { data: newChallenges, error: challengesError } = await supabase\n        .from('challenges')\n        .insert(formattedChallenges)\n        .select('id');\n\n      if (challengesError) throw challengesError;\n\n      challenges = newChallenges;\n    }\n\n    // Vincular los desafíos al journey\n    const journeyMissions = challenges.map((challenge: { id: string }) => ({\n      journeyId: journey.id,\n      challengeId: challenge.id,\n      completed: false,\n      created_at: new Date().toISOString()\n    }));\n\n    console.log('Vincular misiones al journey:', journeyMissions);\n\n    const { error: linkError } = await supabase\n      .from('journeys_missions')\n      .insert(journeyMissions);\n\n    if (linkError) {\n      console.error('Error vinculando misiones:', linkError);\n      throw linkError;\n    }\n\n    // Verificar que las misiones se hayan creado correctamente\n    const { data: createdMissions, error: verifyError } = await supabase\n      .from('journeys_missions')\n      .select(`\n        id,\n        challengeId,\n        completed,\n        challenge:challenges (\n        title,\n        description,\n        difficulty,\n          points\n        )\n      `)\n      .eq('journeyId', journey.id)\n      .order('created_at', { ascending: true });\n\n    if (verifyError) {\n      console.error('Error verificando misiones creadas:', verifyError);\n      throw verifyError;\n    }\n\n    if (!createdMissions || createdMissions.length === 0) {\n      throw new Error('No se pudieron crear las misiones');\n    }\n\n    console.log('Misiones creadas verificadas:', createdMissions);\n\n    return {\n      journeyId: journey.id,\n      challenges: createdMissions\n    };\n  } catch (error) {\n    console.error('Error generando desafíos:', error);\n    throw error;\n  }\n};\n\nexport default generateMission;\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}