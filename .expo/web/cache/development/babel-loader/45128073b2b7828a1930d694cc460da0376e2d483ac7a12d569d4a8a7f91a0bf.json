{"ast":null,"code":"import * as Notifications from 'expo-notifications';\nimport * as Device from 'expo-device';\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport { supabase } from './supabase';\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: true,\n    shouldSetBadge: true\n  })\n});\nexport const registerForPushNotificationsAsync = async () => {\n  let token;\n  if (Platform.OS === 'android') {\n    await Notifications.setNotificationChannelAsync('default', {\n      name: 'default',\n      importance: Notifications.AndroidImportance.MAX,\n      vibrationPattern: [0, 250, 250, 250],\n      lightColor: '#FF231F7C'\n    });\n  }\n  if (Device.isDevice) {\n    const {\n      status: existingStatus\n    } = await Notifications.getPermissionsAsync();\n    let finalStatus = existingStatus;\n    if (existingStatus !== 'granted') {\n      const {\n        status\n      } = await Notifications.requestPermissionsAsync();\n      finalStatus = status;\n    }\n    if (finalStatus !== 'granted') {\n      console.log('Permiso denegado para notificaciones push');\n      return;\n    }\n    token = (await Notifications.getExpoPushTokenAsync()).data;\n  } else {\n    console.log('Debe usar un dispositivo físico para recibir notificaciones push');\n  }\n  return token;\n};\nexport const savePushToken = async (userId, token) => {\n  try {\n    const {\n      error\n    } = await supabase.from('user_push_tokens').upsert({\n      user_id: userId,\n      token,\n      device_id: Device.deviceName,\n      platform: Platform.OS,\n      updated_at: new Date().toISOString()\n    });\n    if (error) throw error;\n  } catch (error) {\n    console.error('Error guardando token de notificación:', error);\n    throw error;\n  }\n};\nexport const scheduleLocalNotification = async (title, body, trigger) => {\n  await Notifications.scheduleNotificationAsync({\n    content: {\n      title,\n      body\n    },\n    trigger\n  });\n};\nexport const sendPushNotification = async (userId, title, body) => {\n  try {\n    const {\n      data: tokenData,\n      error: tokenError\n    } = await supabase.from('user_push_tokens').select('token').eq('user_id', userId).single();\n    if (tokenError) throw tokenError;\n    if (!tokenData) throw new Error('No se encontró token de notificación para el usuario');\n    const message = {\n      to: tokenData.token,\n      sound: 'default',\n      title,\n      body,\n      data: {\n        userId\n      }\n    };\n    await fetch('https://exp.host/--/api/v2/push/send', {\n      method: 'POST',\n      headers: {\n        Accept: 'application/json',\n        'Accept-encoding': 'gzip, deflate',\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(message)\n    });\n  } catch (error) {\n    console.error('Error enviando notificación push:', error);\n    throw error;\n  }\n};","map":{"version":3,"names":["Notifications","Device","Platform","supabase","setNotificationHandler","handleNotification","shouldShowAlert","shouldPlaySound","shouldSetBadge","registerForPushNotificationsAsync","token","OS","setNotificationChannelAsync","name","importance","AndroidImportance","MAX","vibrationPattern","lightColor","isDevice","status","existingStatus","getPermissionsAsync","finalStatus","requestPermissionsAsync","console","log","getExpoPushTokenAsync","data","savePushToken","userId","error","from","upsert","user_id","device_id","deviceName","platform","updated_at","Date","toISOString","scheduleLocalNotification","title","body","trigger","scheduleNotificationAsync","content","sendPushNotification","tokenData","tokenError","select","eq","single","Error","message","to","sound","fetch","method","headers","Accept","JSON","stringify"],"sources":["C:/Users/PC/TravelQuest/src/services/notificationsService.ts"],"sourcesContent":["import * as Notifications from 'expo-notifications';\r\nimport * as Device from 'expo-device';\r\nimport { Platform } from 'react-native';\r\nimport { supabase } from './supabase';\r\n\r\n// Configurar el comportamiento de las notificaciones\r\nNotifications.setNotificationHandler({\r\n    handleNotification: async () => ({\r\n        shouldShowAlert: true,\r\n        shouldPlaySound: true,\r\n        shouldSetBadge: true,\r\n    }),\r\n});\r\n\r\n/**\r\n * Registra el dispositivo para recibir notificaciones push\r\n * @returns token de notificación\r\n */\r\nexport const registerForPushNotificationsAsync = async () => {\r\n    let token;\r\n\r\n    if (Platform.OS === 'android') {\r\n        await Notifications.setNotificationChannelAsync('default', {\r\n            name: 'default',\r\n            importance: Notifications.AndroidImportance.MAX,\r\n            vibrationPattern: [0, 250, 250, 250],\r\n            lightColor: '#FF231F7C',\r\n        });\r\n    }\r\n\r\n    if (Device.isDevice) {\r\n        const { status: existingStatus } = await Notifications.getPermissionsAsync();\r\n        let finalStatus = existingStatus;\r\n\r\n        if (existingStatus !== 'granted') {\r\n            const { status } = await Notifications.requestPermissionsAsync();\r\n            finalStatus = status;\r\n        }\r\n\r\n        if (finalStatus !== 'granted') {\r\n            console.log('Permiso denegado para notificaciones push');\r\n            return;\r\n        }\r\n\r\n        token = (await Notifications.getExpoPushTokenAsync()).data;\r\n    } else {\r\n        console.log('Debe usar un dispositivo físico para recibir notificaciones push');\r\n    }\r\n\r\n    return token;\r\n};\r\n\r\n/**\r\n * Guarda el token de notificación en la base de datos\r\n * @param userId ID del usuario\r\n * @param token Token de notificación\r\n */\r\nexport const savePushToken = async (userId: string, token: string) => {\r\n    try {\r\n        const { error } = await supabase\r\n            .from('user_push_tokens')\r\n            .upsert({\r\n                user_id: userId,\r\n                token,\r\n                device_id: Device.deviceName,\r\n                platform: Platform.OS,\r\n                updated_at: new Date().toISOString(),\r\n            });\r\n\r\n        if (error) throw error;\r\n    } catch (error) {\r\n        console.error('Error guardando token de notificación:', error);\r\n        throw error;\r\n    }\r\n};\r\n\r\n/**\r\n * Programa una notificación local\r\n * @param title Título de la notificación\r\n * @param body Cuerpo de la notificación\r\n * @param trigger Objeto de trigger para la notificación\r\n */\r\nexport const scheduleLocalNotification = async (\r\n    title: string,\r\n    body: string,\r\n    trigger: Notifications.NotificationTriggerInput\r\n) => {\r\n    await Notifications.scheduleNotificationAsync({\r\n        content: {\r\n            title,\r\n            body,\r\n        },\r\n        trigger,\r\n    });\r\n};\r\n\r\n/**\r\n * Envía una notificación push a un usuario específico\r\n * @param userId ID del usuario\r\n * @param title Título de la notificación\r\n * @param body Cuerpo de la notificación\r\n */\r\nexport const sendPushNotification = async (\r\n    userId: string,\r\n    title: string,\r\n    body: string\r\n) => {\r\n    try {\r\n        // Obtener el token del usuario\r\n        const { data: tokenData, error: tokenError } = await supabase\r\n            .from('user_push_tokens')\r\n            .select('token')\r\n            .eq('user_id', userId)\r\n            .single();\r\n\r\n        if (tokenError) throw tokenError;\r\n        if (!tokenData) throw new Error('No se encontró token de notificación para el usuario');\r\n\r\n        // Enviar la notificación usando el token\r\n        const message = {\r\n            to: tokenData.token,\r\n            sound: 'default',\r\n            title,\r\n            body,\r\n            data: { userId },\r\n        };\r\n\r\n        await fetch('https://exp.host/--/api/v2/push/send', {\r\n            method: 'POST',\r\n            headers: {\r\n                Accept: 'application/json',\r\n                'Accept-encoding': 'gzip, deflate',\r\n                'Content-Type': 'application/json',\r\n            },\r\n            body: JSON.stringify(message),\r\n        });\r\n    } catch (error) {\r\n        console.error('Error enviando notificación push:', error);\r\n        throw error;\r\n    }\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}