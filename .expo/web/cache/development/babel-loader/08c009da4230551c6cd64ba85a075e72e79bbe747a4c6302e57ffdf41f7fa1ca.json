{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport { supabase } from \"./supabase\";\nexport var checkJournalTables = function () {\n  var _ref = _asyncToGenerator(function* () {\n    try {\n      var _yield$Promise$allSet = yield Promise.allSettled([supabase.from('journal_entries').select('id').limit(1), supabase.from('journey_diary').select('id').limit(1)]),\n        _yield$Promise$allSet2 = _slicedToArray(_yield$Promise$allSet, 2),\n        journalEntriesResult = _yield$Promise$allSet2[0],\n        journeyDiaryResult = _yield$Promise$allSet2[1];\n      return {\n        journalEntriesExists: journalEntriesResult.status === 'fulfilled' && !journalEntriesResult.value.error,\n        journeyDiaryExists: journeyDiaryResult.status === 'fulfilled' && !journeyDiaryResult.value.error\n      };\n    } catch (error) {\n      console.error('Error verificando tablas del diario:', error);\n      return {\n        journalEntriesExists: false,\n        journeyDiaryExists: false\n      };\n    }\n  });\n  return function checkJournalTables() {\n    return _ref.apply(this, arguments);\n  };\n}();\nexport var getUserJournalEntries = function () {\n  var _ref2 = _asyncToGenerator(function* (userId) {\n    try {\n      var _yield$checkJournalTa = yield checkJournalTables(),\n        journalEntriesExists = _yield$checkJournalTa.journalEntriesExists,\n        journeyDiaryExists = _yield$checkJournalTa.journeyDiaryExists;\n      if (!journalEntriesExists && !journeyDiaryExists) {\n        console.warn('No se encontraron tablas para el diario (journal_entries o journey_diary)');\n        return {};\n      }\n      var entriesData = null;\n      var error = null;\n      if (journalEntriesExists) {\n        try {\n          var _yield$supabase$from$ = yield supabase.from('journal_entries').select(`\n            *,\n            cities:cityId (\n              name\n            )\n          `).eq('userId', userId).order('created_at', {\n              ascending: false\n            }),\n            data = _yield$supabase$from$.data,\n            entriesError = _yield$supabase$from$.error;\n          if (!entriesError) {\n            entriesData = data;\n          } else if (entriesError.message && (entriesError.message.includes('cityId') || entriesError.message.includes('relationship') || entriesError.code === 'PGRST200')) {\n            var _yield$supabase$from$2 = yield supabase.from('journal_entries').select('*').eq('userId', userId).order('created_at', {\n                ascending: false\n              }),\n              basicData = _yield$supabase$from$2.data,\n              basicError = _yield$supabase$from$2.error;\n            if (!basicError) {\n              entriesData = basicData;\n            } else {\n              error = basicError;\n            }\n          } else {\n            error = entriesError;\n          }\n        } catch (e) {\n          console.warn('Error al obtener datos de journal_entries:', e);\n        }\n      }\n      if (!entriesData && journeyDiaryExists) {\n        try {\n          var _yield$supabase$from$3 = yield supabase.from('journey_diary').select(`\n            *,\n            cities:cityId (\n              name\n            )\n          `).eq('userId', userId).order('created_at', {\n              ascending: false\n            }),\n            _data = _yield$supabase$from$3.data,\n            diaryError = _yield$supabase$from$3.error;\n          if (!diaryError) {\n            entriesData = _data;\n          } else if (diaryError.message && (diaryError.message.includes('cityId') || diaryError.message.includes('relationship') || diaryError.code === 'PGRST200')) {\n            var _yield$supabase$from$4 = yield supabase.from('journey_diary').select('*').eq('userId', userId).order('created_at', {\n                ascending: false\n              }),\n              _basicData = _yield$supabase$from$4.data,\n              _basicError = _yield$supabase$from$4.error;\n            if (!_basicError) {\n              entriesData = _basicData;\n            } else if (!error) {\n              error = _basicError;\n            }\n          } else if (!error) {\n            error = diaryError;\n          }\n        } catch (e) {\n          console.warn('Error al obtener datos de journey_diary:', e);\n        }\n      }\n      if (!entriesData && error) {\n        throw error;\n      }\n      if (!entriesData) {\n        return {};\n      }\n      return organizeCityEntries(entriesData, true);\n    } catch (error) {\n      console.error('Error obteniendo entradas del diario:', error);\n      throw error;\n    }\n  });\n  return function getUserJournalEntries(_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();\nvar organizeCityEntries = function organizeCityEntries(data) {\n  var missingCityRelation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var entriesByCity = {};\n  if (!data || data.length === 0) {\n    return entriesByCity;\n  }\n  data.forEach(function (entry) {\n    var _entry$cities;\n    var cityName = 'Ciudad Desconocida';\n    if (!missingCityRelation && (_entry$cities = entry.cities) != null && _entry$cities.name) {\n      cityName = entry.cities.name;\n    } else if (entry.cityName) {\n      cityName = entry.cityName;\n    } else if (entry.city_name) {\n      cityName = entry.city_name;\n    } else {\n      if (entry.tags && Array.isArray(entry.tags)) {\n        var cityTag = entry.tags.find(function (tag) {\n          return tag !== 'misión' && tag !== 'mission' && tag !== 'viaje' && tag !== 'travel';\n        });\n        if (cityTag) {\n          cityName = cityTag.charAt(0).toUpperCase() + cityTag.slice(1);\n        }\n      }\n    }\n    if (!entriesByCity[cityName]) {\n      entriesByCity[cityName] = [];\n    }\n    var processedEntry = {\n      id: entry.id || `generated-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`,\n      userId: entry.userId || '',\n      cityId: entry.cityId || '',\n      missionId: entry.missionId || undefined,\n      title: entry.title || 'Entrada sin título',\n      content: entry.content || '',\n      photos: Array.isArray(entry.photos) ? entry.photos : entry.photos ? [entry.photos] : [],\n      location: entry.location || null,\n      created_at: entry.created_at || new Date().toISOString(),\n      tags: Array.isArray(entry.tags) ? entry.tags : [],\n      city_name: cityName\n    };\n    entriesByCity[cityName].push(processedEntry);\n  });\n  return entriesByCity;\n};\nexport var getMissionJournalEntries = function () {\n  var _ref3 = _asyncToGenerator(function* (userId, missionId) {\n    try {\n      var tableExists = yield checkJournalTables();\n      if (!tableExists.journalEntriesExists) {\n        console.warn('La tabla journal_entries no existe');\n        return [];\n      }\n      try {\n        var _yield$supabase$from$5 = yield supabase.from('journal_entries').select(`\n          *,\n          cities:cityId (\n            name\n          )\n        `).eq('userId', userId).eq('missionId', missionId).order('created_at', {\n            ascending: false\n          }),\n          data = _yield$supabase$from$5.data,\n          error = _yield$supabase$from$5.error;\n        if (error) throw error;\n        if (!data) return [];\n        return data.map(function (entry) {\n          var _entry$cities2;\n          return _objectSpread(_objectSpread({}, entry), {}, {\n            city_name: ((_entry$cities2 = entry.cities) == null ? void 0 : _entry$cities2.name) || 'Ciudad Desconocida'\n          });\n        });\n      } catch (error) {\n        if (error.message && (error.message.includes('cityId') || error.message.includes('relationship') || error.code === 'PGRST200')) {\n          console.warn('Error con la relación cityId, obteniendo solo entradas:', error);\n          var _yield$supabase$from$6 = yield supabase.from('journal_entries').select('*').eq('userId', userId).eq('missionId', missionId).order('created_at', {\n              ascending: false\n            }),\n            _data2 = _yield$supabase$from$6.data,\n            entriesError = _yield$supabase$from$6.error;\n          if (entriesError) throw entriesError;\n          if (!_data2) return [];\n          return _data2.map(function (entry) {\n            return _objectSpread(_objectSpread({}, entry), {}, {\n              city_name: entry.cityName || 'Ciudad Desconocida'\n            });\n          });\n        } else {\n          throw error;\n        }\n      }\n    } catch (error) {\n      console.error('Error obteniendo entradas de la misión:', error);\n      throw error;\n    }\n  });\n  return function getMissionJournalEntries(_x2, _x3) {\n    return _ref3.apply(this, arguments);\n  };\n}();","map":{"version":3,"names":["supabase","checkJournalTables","_ref","_asyncToGenerator","_yield$Promise$allSet","Promise","allSettled","from","select","limit","_yield$Promise$allSet2","_slicedToArray","journalEntriesResult","journeyDiaryResult","journalEntriesExists","status","value","error","journeyDiaryExists","console","apply","arguments","getUserJournalEntries","_ref2","userId","_yield$checkJournalTa","warn","entriesData","_yield$supabase$from$","eq","order","ascending","data","entriesError","message","includes","code","_yield$supabase$from$2","basicData","basicError","e","_yield$supabase$from$3","diaryError","_yield$supabase$from$4","organizeCityEntries","_x","missingCityRelation","length","undefined","entriesByCity","forEach","entry","_entry$cities","cityName","cities","name","city_name","tags","Array","isArray","cityTag","find","tag","charAt","toUpperCase","slice","processedEntry","id","Date","now","Math","random","toString","substring","cityId","missionId","title","content","photos","location","created_at","toISOString","push","getMissionJournalEntries","_ref3","tableExists","_yield$supabase$from$5","map","_entry$cities2","_objectSpread","_yield$supabase$from$6","_x2","_x3"],"sources":["C:/Users/migue/TravelQuest/src/services/journalService.ts"],"sourcesContent":["import { supabase } from './supabase';\r\n\r\nexport interface JournalEntryDB {\r\n  id: string;\r\n  userId: string;\r\n  cityId: string;\r\n  missionId?: string;\r\n  title: string;\r\n  content: string;\r\n  photos: string[];\r\n  location: {\r\n    latitude: number;\r\n    longitude: number;\r\n  } | null;\r\n  created_at: string;\r\n  tags: string[];\r\n}\r\n\r\nexport interface CityJournalEntry extends JournalEntryDB {\r\n  city_name: string;\r\n}\r\n\r\n/**\r\n * Verifica si existe la tabla journal_entries o journey_diary en la base de datos\r\n * @returns objeto con la información de qué tablas existen\r\n */\r\nexport const checkJournalTables = async (): Promise<{journalEntriesExists: boolean, journeyDiaryExists: boolean}> => {\r\n  try {\r\n    // Probamos si las tablas existen obteniendo solo una fila de cada una\r\n    const [journalEntriesResult, journeyDiaryResult] = await Promise.allSettled([\r\n      supabase.from('journal_entries').select('id').limit(1),\r\n      supabase.from('journey_diary').select('id').limit(1)\r\n    ]);\r\n    \r\n    return {\r\n      journalEntriesExists: journalEntriesResult.status === 'fulfilled' && !journalEntriesResult.value.error,\r\n      journeyDiaryExists: journeyDiaryResult.status === 'fulfilled' && !journeyDiaryResult.value.error\r\n    };\r\n  } catch (error) {\r\n    console.error('Error verificando tablas del diario:', error);\r\n    return {\r\n      journalEntriesExists: false,\r\n      journeyDiaryExists: false\r\n    };\r\n  }\r\n};\r\n\r\n/**\r\n * Obtiene todas las entradas del diario del usuario agrupadas por ciudad\r\n * @param userId ID del usuario \r\n * @returns Entradas del diario agrupadas por ciudad\r\n */\r\nexport const getUserJournalEntries = async (userId: string): Promise<{ [cityName: string]: CityJournalEntry[] }> => {\r\n  try {\r\n    // Verificar qué tablas existen\r\n    const { journalEntriesExists, journeyDiaryExists } = await checkJournalTables();\r\n    \r\n    if (!journalEntriesExists && !journeyDiaryExists) {\r\n      console.warn('No se encontraron tablas para el diario (journal_entries o journey_diary)');\r\n      return {}; // Devolvemos un objeto vacío\r\n    }\r\n\r\n    let entriesData = null;\r\n    let error = null;\r\n\r\n    // Primero intentamos con journal_entries si existe\r\n    if (journalEntriesExists) {\r\n      try {\r\n        // Intentamos con la relación a cities\r\n        const { data, error: entriesError } = await supabase\r\n          .from('journal_entries')\r\n          .select(`\r\n            *,\r\n            cities:cityId (\r\n              name\r\n            )\r\n          `)\r\n          .eq('userId', userId)\r\n          .order('created_at', { ascending: false });\r\n\r\n        if (!entriesError) {\r\n          entriesData = data;\r\n        } else if (entriesError.message && (\r\n          entriesError.message.includes('cityId') || \r\n          entriesError.message.includes('relationship') ||\r\n          entriesError.code === 'PGRST200')) {\r\n          \r\n          // Si hay error de relación, intentamos sin la relación\r\n          const { data: basicData, error: basicError } = await supabase\r\n            .from('journal_entries')\r\n            .select('*')\r\n            .eq('userId', userId)\r\n            .order('created_at', { ascending: false });\r\n          \r\n          if (!basicError) {\r\n            entriesData = basicData;\r\n          } else {\r\n            error = basicError;\r\n          }\r\n        } else {\r\n          error = entriesError;\r\n        }\r\n      } catch (e) {\r\n        console.warn('Error al obtener datos de journal_entries:', e);\r\n      }\r\n    }\r\n\r\n    // Si no obtuvimos datos de journal_entries o hubo un error, intentamos con journey_diary\r\n    if (!entriesData && journeyDiaryExists) {\r\n      try {\r\n        // Intentamos con la relación a cities\r\n        const { data, error: diaryError } = await supabase\r\n          .from('journey_diary')\r\n          .select(`\r\n            *,\r\n            cities:cityId (\r\n              name\r\n            )\r\n          `)\r\n          .eq('userId', userId)\r\n          .order('created_at', { ascending: false });\r\n\r\n        if (!diaryError) {\r\n          entriesData = data;\r\n        } else if (diaryError.message && (\r\n          diaryError.message.includes('cityId') || \r\n          diaryError.message.includes('relationship') ||\r\n          diaryError.code === 'PGRST200')) {\r\n          \r\n          // Si hay error de relación, intentamos sin la relación\r\n          const { data: basicData, error: basicError } = await supabase\r\n            .from('journey_diary')\r\n            .select('*')\r\n            .eq('userId', userId)\r\n            .order('created_at', { ascending: false });\r\n          \r\n          if (!basicError) {\r\n            entriesData = basicData;\r\n          } else if (!error) { // Solo guardamos este error si no teníamos uno previo\r\n            error = basicError;\r\n          }\r\n        } else if (!error) { // Solo guardamos este error si no teníamos uno previo\r\n          error = diaryError;\r\n        }\r\n      } catch (e) {\r\n        console.warn('Error al obtener datos de journey_diary:', e);\r\n      }\r\n    }\r\n\r\n    // Si después de intentar con ambas tablas seguimos sin datos y tenemos un error, lo lanzamos\r\n    if (!entriesData && error) {\r\n      throw error;\r\n    }\r\n\r\n    // Si no hay datos (pero no hubo error), devolvemos un objeto vacío\r\n    if (!entriesData) {\r\n      return {};\r\n    }\r\n    \r\n    // Organizar las entradas por ciudad\r\n    return organizeCityEntries(entriesData, true);\r\n  } catch (error) {\r\n    console.error('Error obteniendo entradas del diario:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Organiza las entradas del diario por ciudad\r\n * @param data Datos de las entradas\r\n * @param missingCityRelation Indica si falta la relación con la ciudad\r\n * @returns Entradas organizadas por ciudad\r\n */\r\nconst organizeCityEntries = (\r\n  data: any[] | null, \r\n  missingCityRelation: boolean = false\r\n): { [cityName: string]: CityJournalEntry[] } => {\r\n  const entriesByCity: { [cityName: string]: CityJournalEntry[] } = {};\r\n  \r\n  if (!data || data.length === 0) {\r\n    return entriesByCity;\r\n  }\r\n  \r\n  data.forEach((entry: any) => {\r\n    let cityName = 'Ciudad Desconocida';\r\n    \r\n    // Intentamos obtener el nombre de la ciudad de varias formas posibles\r\n    if (!missingCityRelation && entry.cities?.name) {\r\n      cityName = entry.cities.name;\r\n    } else if (entry.cityName) {\r\n      cityName = entry.cityName;\r\n    } else if (entry.city_name) {\r\n      cityName = entry.city_name;\r\n    } else {\r\n      // Buscar el cityId en las etiquetas y usar la primera que parece ser un nombre de ciudad\r\n      if (entry.tags && Array.isArray(entry.tags)) {\r\n        const cityTag = entry.tags.find((tag: string) => \r\n          tag !== 'misión' && tag !== 'mission' && tag !== 'viaje' && tag !== 'travel'\r\n        );\r\n        if (cityTag) {\r\n          cityName = cityTag.charAt(0).toUpperCase() + cityTag.slice(1); // Capitalizar\r\n        }\r\n      }\r\n    }\r\n    \r\n    if (!entriesByCity[cityName]) {\r\n      entriesByCity[cityName] = [];\r\n    }\r\n    \r\n    // Nos aseguramos de que todos los campos necesarios existan\r\n    const processedEntry: CityJournalEntry = {\r\n      id: entry.id || `generated-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`,\r\n      userId: entry.userId || '',\r\n      cityId: entry.cityId || '',\r\n      missionId: entry.missionId || undefined,\r\n      title: entry.title || 'Entrada sin título',\r\n      content: entry.content || '',\r\n      photos: Array.isArray(entry.photos) ? entry.photos : \r\n              (entry.photos ? [entry.photos] : []),\r\n      location: entry.location || null,\r\n      created_at: entry.created_at || new Date().toISOString(),\r\n      tags: Array.isArray(entry.tags) ? entry.tags : [],\r\n      city_name: cityName\r\n    };\r\n    \r\n    entriesByCity[cityName].push(processedEntry);\r\n  });\r\n\r\n  return entriesByCity;\r\n};\r\n\r\n/**\r\n * Obtiene las entradas del diario relacionadas con una misión específica\r\n * @param userId ID del usuario\r\n * @param missionId ID de la misión\r\n * @returns Entradas del diario relacionadas con la misión\r\n */\r\nexport const getMissionJournalEntries = async (userId: string, missionId: string): Promise<CityJournalEntry[]> => {\r\n  try {\r\n    // Verificar si la tabla existe\r\n    const tableExists = await checkJournalTables();\r\n    if (!tableExists.journalEntriesExists) {\r\n      console.warn('La tabla journal_entries no existe');\r\n      return []; // Devolvemos un array vacío\r\n    }\r\n\r\n    // Primero intentamos con la relación cityId a cities\r\n    try {\r\n      const { data, error } = await supabase\r\n        .from('journal_entries')\r\n        .select(`\r\n          *,\r\n          cities:cityId (\r\n            name\r\n          )\r\n        `)\r\n        .eq('userId', userId)\r\n        .eq('missionId', missionId)\r\n        .order('created_at', { ascending: false });\r\n\r\n      if (error) throw error;\r\n\r\n      if (!data) return [];\r\n      \r\n      return data.map((entry: any) => ({\r\n        ...entry,\r\n        city_name: entry.cities?.name || 'Ciudad Desconocida'\r\n      }));\r\n    } catch (error: any) {\r\n      // Si hay un error con la relación, intentamos obtener solo las entradas\r\n      if (error.message && (\r\n          error.message.includes('cityId') || \r\n          error.message.includes('relationship') ||\r\n          error.code === 'PGRST200')) {\r\n            \r\n        console.warn('Error con la relación cityId, obteniendo solo entradas:', error);\r\n        \r\n        const { data, error: entriesError } = await supabase\r\n          .from('journal_entries')\r\n          .select('*')\r\n          .eq('userId', userId)\r\n          .eq('missionId', missionId)\r\n          .order('created_at', { ascending: false });\r\n        \r\n        if (entriesError) throw entriesError;\r\n        \r\n        if (!data) return [];\r\n        \r\n        return data.map((entry: any) => ({\r\n          ...entry,\r\n          city_name: entry.cityName || 'Ciudad Desconocida'\r\n        }));\r\n      } else {\r\n        throw error;\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.error('Error obteniendo entradas de la misión:', error);\r\n    throw error;\r\n  }\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}