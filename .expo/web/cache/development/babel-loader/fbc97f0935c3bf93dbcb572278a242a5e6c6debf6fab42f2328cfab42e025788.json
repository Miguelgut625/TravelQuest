{"ast":null,"code":"import * as Notifications from 'expo-notifications';\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport { supabase } from './supabase';\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: true,\n    shouldSetBadge: true\n  })\n});\nclass NotificationService {\n  constructor() {\n    this.configureNotifications();\n  }\n  static getInstance() {\n    if (!NotificationService.instance) {\n      NotificationService.instance = new NotificationService();\n    }\n    return NotificationService.instance;\n  }\n  async configureNotifications() {\n    try {\n      const {\n        status: existingStatus\n      } = await Notifications.getPermissionsAsync();\n      let finalStatus = existingStatus;\n      if (existingStatus !== 'granted') {\n        const {\n          status\n        } = await Notifications.requestPermissionsAsync();\n        finalStatus = status;\n      }\n      if (finalStatus !== 'granted') {\n        console.log('Permiso para notificaciones denegado');\n        return;\n      }\n      if (Platform.OS === 'android') {\n        await Notifications.setNotificationChannelAsync('default', {\n          name: 'default',\n          importance: Notifications.AndroidImportance.MAX,\n          vibrationPattern: [0, 250, 250, 250],\n          lightColor: '#FF231F7C'\n        });\n      }\n    } catch (error) {\n      console.error('Error al configurar notificaciones:', error);\n    }\n  }\n  async scheduleLocalNotification(title, body, trigger, userId) {\n    try {\n      if (Platform.OS === 'web') {\n        if (true && 'Notification' in window) {\n          if (window.Notification.permission === \"granted\") {\n            new window.Notification(title, {\n              body: body,\n              icon: '/icon.png'\n            });\n          } else if (window.Notification.permission !== \"denied\") {\n            window.Notification.requestPermission().then(permission => {\n              if (permission === \"granted\") {\n                new window.Notification(title, {\n                  body: body,\n                  icon: '/icon.png'\n                });\n              }\n            });\n          }\n        }\n        const {\n          error\n        } = await supabase.from('notifications').insert({\n          userid: userId,\n          title,\n          message: body,\n          type: 'local',\n          read: false,\n          created_at: new Date().toISOString(),\n          updated_at: new Date().toISOString()\n        });\n        if (error) {\n          console.error('Error al guardar notificación en la base de datos:', error);\n        }\n        return;\n      }\n      await Notifications.scheduleNotificationAsync({\n        content: {\n          title,\n          body,\n          sound: true,\n          priority: Notifications.AndroidNotificationPriority.HIGH\n        },\n        trigger\n      });\n      const {\n        error\n      } = await supabase.from('notifications').insert({\n        userid: userId,\n        title,\n        message: body,\n        type: 'local',\n        read: false,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString()\n      });\n      if (error) {\n        console.error('Error al guardar notificación en la base de datos:', error);\n      }\n    } catch (error) {\n      console.error('Error al programar notificación local:', error);\n    }\n  }\n  async notifyJourneyShared(userId, journeyName, sharedBy) {\n    const title = '¡Nuevo viaje compartido!';\n    const body = `${sharedBy} ha compartido el viaje \"${journeyName}\" contigo`;\n    try {\n      const {\n        error\n      } = await supabase.from('notifications').insert({\n        userid: userId,\n        title,\n        message: body,\n        type: 'journey_shared',\n        read: false,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString()\n      });\n      if (error) {\n        console.error('Error al guardar notificación de viaje compartido:', error);\n        return;\n      }\n      if (Platform.OS === 'web') {\n        if (true && 'Notification' in window) {\n          if (window.Notification.permission === \"granted\") {\n            new window.Notification(title, {\n              body: body,\n              icon: '/icon.png'\n            });\n          } else if (window.Notification.permission !== \"denied\") {\n            window.Notification.requestPermission().then(permission => {\n              if (permission === \"granted\") {\n                new window.Notification(title, {\n                  body: body,\n                  icon: '/icon.png'\n                });\n              }\n            });\n          }\n        }\n      } else {\n        await Notifications.scheduleNotificationAsync({\n          content: {\n            title,\n            body,\n            sound: true,\n            priority: Notifications.AndroidNotificationPriority.HIGH\n          },\n          trigger: {\n            seconds: 1\n          }\n        });\n      }\n    } catch (error) {\n      console.error('Error al enviar notificación de viaje compartido:', error);\n    }\n  }\n  async cleanupOldNotifications(userId) {\n    try {\n      const {\n        error\n      } = await supabase.from('notifications').delete().eq('userid', userId).lt('created_at', new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString());\n      if (error) throw error;\n      console.log('Notificaciones antiguas limpiadas correctamente');\n    } catch (error) {\n      console.error('Error al limpiar notificaciones antiguas:', error);\n    }\n  }\n  async notifyJourneyEnding(userId, journeyDescription, hoursLeft) {\n    try {\n      await this.cleanupOldNotifications(userId);\n      const {\n        data: existingNotifications,\n        error: checkError\n      } = await supabase.from('notifications').select('id, created_at').eq('userid', userId).eq('type', 'journey_ending').eq('data->>journeyDescription', journeyDescription).gte('created_at', new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString()).limit(1);\n      if (checkError) throw checkError;\n      if (existingNotifications && existingNotifications.length > 0) {\n        console.log('Ya existe una notificación para este viaje en las últimas 24 horas');\n        return;\n      }\n      const title = '¡Tu viaje está por terminar!';\n      const message = `Te quedan ${hoursLeft} horas para completar las misiones de ${journeyDescription}. ¡No te quedes sin puntos!`;\n      const {\n        data: newNotification,\n        error: createError\n      } = await supabase.from('notifications').insert({\n        userid: userId,\n        title,\n        message,\n        type: 'journey_ending',\n        read: false,\n        data: {\n          journeyDescription,\n          hoursLeft\n        },\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString()\n      }).select().single();\n      if (createError) throw createError;\n      if (newNotification) {\n        await this.scheduleLocalNotification(title, message, {\n          seconds: 1\n        }, userId);\n      }\n    } catch (error) {\n      console.error('Error al notificar fin de viaje:', error);\n      throw error;\n    }\n  }\n  async notifyFriendRequest(userId, requesterName) {\n    const title = '¡Nueva solicitud de amistad!';\n    const body = `${requesterName} quiere ser tu amigo/a`;\n    try {\n      const {\n        error\n      } = await supabase.from('notifications').insert({\n        userid: userId,\n        title,\n        message: body,\n        type: 'friend_request',\n        read: false,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString()\n      });\n      if (error) {\n        console.error('Error al guardar notificación de solicitud de amistad:', error);\n        return;\n      }\n      if (Platform.OS === 'web') {\n        if (true && 'Notification' in window) {\n          if (window.Notification.permission === \"granted\") {\n            new window.Notification(title, {\n              body: body,\n              icon: '/icon.png'\n            });\n          } else if (window.Notification.permission !== \"denied\") {\n            window.Notification.requestPermission().then(permission => {\n              if (permission === \"granted\") {\n                new window.Notification(title, {\n                  body: body,\n                  icon: '/icon.png'\n                });\n              }\n            });\n          }\n        }\n      } else {\n        await Notifications.scheduleNotificationAsync({\n          content: {\n            title,\n            body,\n            sound: true,\n            priority: Notifications.AndroidNotificationPriority.HIGH\n          },\n          trigger: {\n            seconds: 1\n          }\n        });\n      }\n    } catch (error) {\n      console.error('Error al enviar notificación de solicitud de amistad:', error);\n    }\n  }\n  async getUnreadNotifications(userId) {\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from('notifications').select('*').eq('userid', userId).eq('read', false).order('created_at', {\n        ascending: false\n      });\n      if (error) throw error;\n      return data || [];\n    } catch (error) {\n      console.error('Error al obtener notificaciones:', error);\n      return [];\n    }\n  }\n  async markNotificationAsRead(notificationId) {\n    try {\n      const {\n        data: notification,\n        error: fetchError\n      } = await supabase.from('notifications').select('*').eq('id', notificationId).single();\n      if (fetchError) throw fetchError;\n      if (!notification) throw new Error('Notificación no encontrada');\n      const {\n        error: updateError\n      } = await supabase.from('notifications').update({\n        read: true,\n        updated_at: new Date().toISOString()\n      }).eq('id', notificationId);\n      if (updateError) throw updateError;\n      console.log('Notificación marcada como leída correctamente');\n    } catch (error) {\n      console.error('Error al marcar notificación como leída:', error);\n      throw error;\n    }\n  }\n  async cancelAllNotifications() {\n    await Notifications.cancelAllScheduledNotificationsAsync();\n  }\n  async cancelNotification(notificationId) {\n    await Notifications.cancelScheduledNotificationAsync(notificationId);\n  }\n  async createNotification(userId, title, message, type, data) {\n    try {\n      const {\n        error\n      } = await supabase.from('notifications').insert({\n        userid: userId,\n        title,\n        message,\n        type,\n        read: false,\n        data,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString()\n      });\n      if (error) throw error;\n    } catch (error) {\n      console.error('Error al crear notificación:', error);\n      throw error;\n    }\n  }\n  async registerForPushNotificationsAsync() {\n    try {\n      if (Platform.OS === 'web') {\n        console.log('Las notificaciones push no están disponibles en web');\n        return null;\n      }\n      const {\n        status: existingStatus\n      } = await Notifications.getPermissionsAsync();\n      let finalStatus = existingStatus;\n      if (existingStatus !== 'granted') {\n        const {\n          status\n        } = await Notifications.requestPermissionsAsync();\n        finalStatus = status;\n      }\n      if (finalStatus !== 'granted') {\n        console.log('Permiso para notificaciones push denegado');\n        return null;\n      }\n      const token = (await Notifications.getExpoPushTokenAsync()).data;\n      return token;\n    } catch (error) {\n      console.error('Error al registrar notificaciones push:', error);\n      return null;\n    }\n  }\n}\nexport default NotificationService;","map":{"version":3,"names":["Notifications","Platform","supabase","setNotificationHandler","handleNotification","shouldShowAlert","shouldPlaySound","shouldSetBadge","NotificationService","constructor","configureNotifications","getInstance","instance","status","existingStatus","getPermissionsAsync","finalStatus","requestPermissionsAsync","console","log","OS","setNotificationChannelAsync","name","importance","AndroidImportance","MAX","vibrationPattern","lightColor","error","scheduleLocalNotification","title","body","trigger","userId","window","Notification","permission","icon","requestPermission","then","from","insert","userid","message","type","read","created_at","Date","toISOString","updated_at","scheduleNotificationAsync","content","sound","priority","AndroidNotificationPriority","HIGH","notifyJourneyShared","journeyName","sharedBy","seconds","cleanupOldNotifications","delete","eq","lt","now","notifyJourneyEnding","journeyDescription","hoursLeft","data","existingNotifications","checkError","select","gte","limit","length","newNotification","createError","single","notifyFriendRequest","requesterName","getUnreadNotifications","order","ascending","markNotificationAsRead","notificationId","notification","fetchError","Error","updateError","update","cancelAllNotifications","cancelAllScheduledNotificationsAsync","cancelNotification","cancelScheduledNotificationAsync","createNotification","registerForPushNotificationsAsync","token","getExpoPushTokenAsync"],"sources":["C:/Users/Admin/TravelQuest/src/services/NotificationService.ts"],"sourcesContent":["import * as Notifications from 'expo-notifications';\r\nimport { Platform } from 'react-native';\r\nimport { supabase } from './supabase';\r\nimport { Notification } from '../types/notifications';\r\n\r\n// Configurar el comportamiento de las notificaciones\r\nNotifications.setNotificationHandler({\r\n    handleNotification: async () => ({\r\n        shouldShowAlert: true,\r\n        shouldPlaySound: true,\r\n        shouldSetBadge: true,\r\n    }),\r\n});\r\n\r\nclass NotificationService {\r\n    private static instance: NotificationService;\r\n\r\n    private constructor() {\r\n        this.configureNotifications();\r\n    }\r\n\r\n    public static getInstance(): NotificationService {\r\n        if (!NotificationService.instance) {\r\n            NotificationService.instance = new NotificationService();\r\n        }\r\n        return NotificationService.instance;\r\n    }\r\n\r\n    private async configureNotifications() {\r\n        try {\r\n            // Solicitar permisos\r\n            const { status: existingStatus } = await Notifications.getPermissionsAsync();\r\n            let finalStatus = existingStatus;\r\n\r\n            if (existingStatus !== 'granted') {\r\n                const { status } = await Notifications.requestPermissionsAsync();\r\n                finalStatus = status;\r\n            }\r\n\r\n            if (finalStatus !== 'granted') {\r\n                console.log('Permiso para notificaciones denegado');\r\n                return;\r\n            }\r\n\r\n            // Configurar el canal de notificaciones para Android\r\n            if (Platform.OS === 'android') {\r\n                await Notifications.setNotificationChannelAsync('default', {\r\n                    name: 'default',\r\n                    importance: Notifications.AndroidImportance.MAX,\r\n                    vibrationPattern: [0, 250, 250, 250],\r\n                    lightColor: '#FF231F7C',\r\n                });\r\n            }\r\n        } catch (error) {\r\n            console.error('Error al configurar notificaciones:', error);\r\n        }\r\n    }\r\n\r\n    // Método para programar una notificación local\r\n    public async scheduleLocalNotification(\r\n        title: string,\r\n        body: string,\r\n        trigger: Notifications.NotificationTriggerInput,\r\n        userId: string\r\n    ) {\r\n        try {\r\n            // Verificar si estamos en web\r\n            if (Platform.OS === 'web') {\r\n                // Verificar si el navegador soporta notificaciones\r\n                if (typeof window !== 'undefined' && 'Notification' in window) {\r\n                    if (window.Notification.permission === \"granted\") {\r\n                        new window.Notification(title, {\r\n                            body: body,\r\n                            icon: '/icon.png'\r\n                        });\r\n                    } else if (window.Notification.permission !== \"denied\") {\r\n                        window.Notification.requestPermission().then((permission: string) => {\r\n                            if (permission === \"granted\") {\r\n                                new window.Notification(title, {\r\n                                    body: body,\r\n                                    icon: '/icon.png'\r\n                                });\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n\r\n                // Guardar la notificación en la base de datos\r\n                const { error } = await supabase\r\n                    .from('notifications')\r\n                    .insert({\r\n                        userid: userId,\r\n                        title,\r\n                        message: body,\r\n                        type: 'local',\r\n                        read: false,\r\n                        created_at: new Date().toISOString(),\r\n                        updated_at: new Date().toISOString()\r\n                    });\r\n\r\n                if (error) {\r\n                    console.error('Error al guardar notificación en la base de datos:', error);\r\n                }\r\n                return;\r\n            }\r\n\r\n            // Para plataformas móviles\r\n            await Notifications.scheduleNotificationAsync({\r\n                content: {\r\n                    title,\r\n                    body,\r\n                    sound: true,\r\n                    priority: Notifications.AndroidNotificationPriority.HIGH,\r\n                },\r\n                trigger,\r\n            });\r\n\r\n            // Guardar la notificación en la base de datos\r\n            const { error } = await supabase\r\n                .from('notifications')\r\n                .insert({\r\n                    userid: userId,\r\n                    title,\r\n                    message: body,\r\n                    type: 'local',\r\n                    read: false,\r\n                    created_at: new Date().toISOString(),\r\n                    updated_at: new Date().toISOString()\r\n                });\r\n\r\n            if (error) {\r\n                console.error('Error al guardar notificación en la base de datos:', error);\r\n            }\r\n        } catch (error) {\r\n            console.error('Error al programar notificación local:', error);\r\n        }\r\n    }\r\n\r\n    // Método para notificar cuando alguien comparte un viaje\r\n    public async notifyJourneyShared(\r\n        userId: string,\r\n        journeyName: string,\r\n        sharedBy: string\r\n    ) {\r\n        const title = '¡Nuevo viaje compartido!';\r\n        const body = `${sharedBy} ha compartido el viaje \"${journeyName}\" contigo`;\r\n\r\n        try {\r\n            // Guardar en base de datos\r\n            const { error } = await supabase\r\n                .from('notifications')\r\n                .insert({\r\n                    userid: userId,\r\n                    title,\r\n                    message: body,\r\n                    type: 'journey_shared',\r\n                    read: false,\r\n                    created_at: new Date().toISOString(),\r\n                    updated_at: new Date().toISOString()\r\n                });\r\n\r\n            if (error) {\r\n                console.error('Error al guardar notificación de viaje compartido:', error);\r\n                return;\r\n            }\r\n\r\n\r\n            if (Platform.OS === 'web') {\r\n                // Verificar si el navegador soporta notificaciones\r\n                if (typeof window !== 'undefined' && 'Notification' in window) {\r\n                    if (window.Notification.permission === \"granted\") {\r\n                        new window.Notification(title, {\r\n                            body: body,\r\n                            icon: '/icon.png'\r\n                        });\r\n                    } else if (window.Notification.permission !== \"denied\") {\r\n                        window.Notification.requestPermission().then((permission: string) => {\r\n                            if (permission === \"granted\") {\r\n                                new window.Notification(title, {\r\n                                    body: body,\r\n                                    icon: '/icon.png'\r\n                                });\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            } else {\r\n                // Para plataformas móviles\r\n                await Notifications.scheduleNotificationAsync({\r\n                    content: {\r\n                        title,\r\n                        body,\r\n                        sound: true,\r\n                        priority: Notifications.AndroidNotificationPriority.HIGH,\r\n                    },\r\n                    trigger: { seconds: 1 },\r\n                });\r\n            }\r\n        } catch (error) {\r\n            console.error('Error al enviar notificación de viaje compartido:', error);\r\n        }\r\n    }\r\n\r\n    // Método para limpiar notificaciones antiguas\r\n    private async cleanupOldNotifications(userId: string): Promise<void> {\r\n        try {\r\n            const { error } = await supabase\r\n                .from('notifications')\r\n                .delete()\r\n                .eq('userid', userId)\r\n                .lt('created_at', new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString());\r\n\r\n            if (error) throw error;\r\n            console.log('Notificaciones antiguas limpiadas correctamente');\r\n        } catch (error) {\r\n            console.error('Error al limpiar notificaciones antiguas:', error);\r\n        }\r\n    }\r\n\r\n    // Método para notificar sobre un viaje que está por terminar\r\n    public async notifyJourneyEnding(\r\n        userId: string,\r\n        journeyDescription: string,\r\n        hoursLeft: number\r\n    ): Promise<void> {\r\n        try {\r\n            // Limpiar notificaciones antiguas primero\r\n            await this.cleanupOldNotifications(userId);\r\n\r\n            // Verificar si ya existe una notificación similar en las últimas 24 horas\r\n            const { data: existingNotifications, error: checkError } = await supabase\r\n                .from('notifications')\r\n                .select('id, created_at')\r\n                .eq('userid', userId)\r\n                .eq('type', 'journey_ending')\r\n                .eq('data->>journeyDescription', journeyDescription)\r\n                .gte('created_at', new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString())\r\n                .limit(1);\r\n\r\n            if (checkError) throw checkError;\r\n\r\n            // Si ya existe una notificación en las últimas 24 horas, no crear una nueva\r\n            if (existingNotifications && existingNotifications.length > 0) {\r\n                console.log('Ya existe una notificación para este viaje en las últimas 24 horas');\r\n                return;\r\n            }\r\n\r\n            const title = '¡Tu viaje está por terminar!';\r\n            const message = `Te quedan ${hoursLeft} horas para completar las misiones de ${journeyDescription}. ¡No te quedes sin puntos!`;\r\n\r\n            // Crear la notificación en la base de datos\r\n            const { data: newNotification, error: createError } = await supabase\r\n                .from('notifications')\r\n                .insert({\r\n                    userid: userId,\r\n                    title,\r\n                    message,\r\n                    type: 'journey_ending',\r\n                    read: false,\r\n                    data: { journeyDescription, hoursLeft },\r\n                    created_at: new Date().toISOString(),\r\n                    updated_at: new Date().toISOString()\r\n                })\r\n                .select()\r\n                .single();\r\n\r\n            if (createError) throw createError;\r\n\r\n            // Programar la notificación local solo si se creó correctamente en la base de datos\r\n            if (newNotification) {\r\n                await this.scheduleLocalNotification(\r\n                    title,\r\n                    message,\r\n                    { seconds: 1 },\r\n                    userId\r\n                );\r\n            }\r\n        } catch (error) {\r\n            console.error('Error al notificar fin de viaje:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    // Método para notificar cuando alguien envía una solicitud de amistad\r\n    public async notifyFriendRequest(\r\n        userId: string,\r\n        requesterName: string\r\n    ) {\r\n        const title = '¡Nueva solicitud de amistad!';\r\n        const body = `${requesterName} quiere ser tu amigo/a`;\r\n\r\n        try {\r\n            // Guardar en base de datos y mostrar notificación local\r\n            const { error } = await supabase\r\n                .from('notifications')\r\n                .insert({\r\n                    userid: userId,\r\n                    title,\r\n                    message: body,\r\n                    type: 'friend_request',\r\n                    read: false,\r\n                    created_at: new Date().toISOString(),\r\n                    updated_at: new Date().toISOString()\r\n                });\r\n\r\n            if (error) {\r\n                console.error('Error al guardar notificación de solicitud de amistad:', error);\r\n                return;\r\n            }\r\n\r\n            // Mostrar notificación local sin guardarla en la base de datos\r\n            if (Platform.OS === 'web') {\r\n                // Verificar si el navegador soporta notificaciones\r\n                if (typeof window !== 'undefined' && 'Notification' in window) {\r\n                    if (window.Notification.permission === \"granted\") {\r\n                        new window.Notification(title, {\r\n                            body: body,\r\n                            icon: '/icon.png'\r\n                        });\r\n                    } else if (window.Notification.permission !== \"denied\") {\r\n                        window.Notification.requestPermission().then((permission: string) => {\r\n                            if (permission === \"granted\") {\r\n                                new window.Notification(title, {\r\n                                    body: body,\r\n                                    icon: '/icon.png'\r\n                                });\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            } else {\r\n                // Para plataformas móviles\r\n                await Notifications.scheduleNotificationAsync({\r\n                    content: {\r\n                        title,\r\n                        body,\r\n                        sound: true,\r\n                        priority: Notifications.AndroidNotificationPriority.HIGH,\r\n                    },\r\n                    trigger: { seconds: 1 },\r\n                });\r\n            }\r\n        } catch (error) {\r\n            console.error('Error al enviar notificación de solicitud de amistad:', error);\r\n        }\r\n    }\r\n\r\n    // Método para obtener notificaciones no leídas\r\n    public async getUnreadNotifications(userId: string): Promise<Notification[]> {\r\n        try {\r\n            const { data, error } = await supabase\r\n                .from('notifications')\r\n                .select('*')\r\n                .eq('userid', userId)\r\n                .eq('read', false)\r\n                .order('created_at', { ascending: false });\r\n\r\n            if (error) throw error;\r\n            return data || [];\r\n        } catch (error) {\r\n            console.error('Error al obtener notificaciones:', error);\r\n            return [];\r\n        }\r\n    }\r\n\r\n    // Método para marcar una notificación como leída\r\n    public async markNotificationAsRead(notificationId: string): Promise<void> {\r\n        try {\r\n            // Primero obtenemos la notificación para verificar que existe\r\n            const { data: notification, error: fetchError } = await supabase\r\n                .from('notifications')\r\n                .select('*')\r\n                .eq('id', notificationId)\r\n                .single();\r\n\r\n            if (fetchError) throw fetchError;\r\n            if (!notification) throw new Error('Notificación no encontrada');\r\n\r\n            // Actualizar la notificación como leída\r\n            const { error: updateError } = await supabase\r\n                .from('notifications')\r\n                .update({ \r\n                    read: true,\r\n                    updated_at: new Date().toISOString()\r\n                })\r\n                .eq('id', notificationId);\r\n\r\n            if (updateError) throw updateError;\r\n\r\n            console.log('Notificación marcada como leída correctamente');\r\n        } catch (error) {\r\n            console.error('Error al marcar notificación como leída:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    // Método para cancelar todas las notificaciones programadas\r\n    public async cancelAllNotifications() {\r\n        await Notifications.cancelAllScheduledNotificationsAsync();\r\n    }\r\n\r\n    // Método para cancelar una notificación específica por ID\r\n    public async cancelNotification(notificationId: string) {\r\n        await Notifications.cancelScheduledNotificationAsync(notificationId);\r\n    }\r\n\r\n    // Método para crear una notificación en la base de datos\r\n    public async createNotification(\r\n        userId: string,\r\n        title: string,\r\n        message: string,\r\n        type: string,\r\n        data?: any\r\n    ): Promise<void> {\r\n        try {\r\n            const { error } = await supabase\r\n                .from('notifications')\r\n                .insert({\r\n                    userid: userId,\r\n                    title,\r\n                    message,\r\n                    type,\r\n                    read: false,\r\n                    data,\r\n                    created_at: new Date().toISOString(),\r\n                    updated_at: new Date().toISOString()\r\n                });\r\n\r\n            if (error) throw error;\r\n        } catch (error) {\r\n            console.error('Error al crear notificación:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    // Método para registrar el dispositivo para notificaciones push\r\n    public async registerForPushNotificationsAsync(): Promise<string | null> {\r\n        try {\r\n            // Verificar si estamos en web\r\n            if (Platform.OS === 'web') {\r\n                console.log('Las notificaciones push no están disponibles en web');\r\n                return null;\r\n            }\r\n\r\n            const { status: existingStatus } = await Notifications.getPermissionsAsync();\r\n            let finalStatus = existingStatus;\r\n\r\n            if (existingStatus !== 'granted') {\r\n                const { status } = await Notifications.requestPermissionsAsync();\r\n                finalStatus = status;\r\n            }\r\n\r\n            if (finalStatus !== 'granted') {\r\n                console.log('Permiso para notificaciones push denegado');\r\n                return null;\r\n            }\r\n\r\n            const token = (await Notifications.getExpoPushTokenAsync()).data;\r\n            return token;\r\n        } catch (error) {\r\n            console.error('Error al registrar notificaciones push:', error);\r\n            return null;\r\n        }\r\n    }\r\n}\r\n\r\nexport default NotificationService; "],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}