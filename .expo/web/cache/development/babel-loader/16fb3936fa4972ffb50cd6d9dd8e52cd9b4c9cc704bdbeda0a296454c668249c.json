{"ast":null,"code":"import * as Notifications from 'expo-notifications';\nimport * as Device from 'expo-device';\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport { supabase } from './supabase';\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: true,\n    shouldSetBadge: true\n  })\n});\nexport class NotificationService {\n  static async registerForPushNotificationsAsync() {\n    let token;\n    if (Platform.OS === 'android') {\n      await Notifications.setNotificationChannelAsync('default', {\n        name: 'default',\n        importance: Notifications.AndroidImportance.MAX,\n        vibrationPattern: [0, 250, 250, 250],\n        lightColor: '#FF231F7C'\n      });\n    }\n    if (Device.isDevice) {\n      const {\n        status: existingStatus\n      } = await Notifications.getPermissionsAsync();\n      let finalStatus = existingStatus;\n      if (existingStatus !== 'granted') {\n        const {\n          status\n        } = await Notifications.requestPermissionsAsync();\n        finalStatus = status;\n      }\n      if (finalStatus !== 'granted') {\n        console.log('Failed to get push token for push notification!');\n        return;\n      }\n      token = (await Notifications.getExpoPushTokenAsync()).data;\n      const {\n        data: {\n          user\n        }\n      } = await supabase.auth.getUser();\n      if (user) {\n        await this.savePushToken(user.id, token);\n      }\n    } else {\n      console.log('Must use physical device for Push Notifications');\n    }\n    return token;\n  }\n  static async savePushToken(userId, token) {\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from('user_push_tokens').upsert({\n        user_id: userId,\n        token: token,\n        device_id: Device.modelName,\n        platform: Platform.OS\n      }, {\n        onConflict: 'user_id,token'\n      }).select().single();\n      if (error) throw error;\n      return data;\n    } catch (error) {\n      console.error('Error saving push token:', error);\n      throw error;\n    }\n  }\n  static async createNotification(userId, title, message, type, data) {\n    try {\n      const {\n        data: notification,\n        error\n      } = await supabase.from('notifications').insert({\n        userid: userId,\n        title,\n        message,\n        type,\n        data,\n        read: false\n      }).select().single();\n      if (error) throw error;\n      await this.scheduleNotification(title, message, data);\n      return notification;\n    } catch (error) {\n      console.error('Error creating notification:', error);\n      throw error;\n    }\n  }\n  static async getUnreadNotifications(userId) {\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from('notifications').select('*').eq('userid', userId).eq('read', false).order('created_at', {\n        ascending: false\n      });\n      if (error) throw error;\n      return data;\n    } catch (error) {\n      console.error('Error getting unread notifications:', error);\n      throw error;\n    }\n  }\n  static async markNotificationAsRead(notificationId) {\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from('notifications').update({\n        read: true\n      }).eq('id', notificationId).select().single();\n      if (error) throw error;\n      return data;\n    } catch (error) {\n      console.error('Error marking notification as read:', error);\n      throw error;\n    }\n  }\n  static async scheduleNotification(title, body, data = {}) {\n    await Notifications.scheduleNotificationAsync({\n      content: {\n        title,\n        body,\n        data\n      },\n      trigger: null\n    });\n  }\n}","map":{"version":3,"names":["Notifications","Device","Platform","supabase","setNotificationHandler","handleNotification","shouldShowAlert","shouldPlaySound","shouldSetBadge","NotificationService","registerForPushNotificationsAsync","token","OS","setNotificationChannelAsync","name","importance","AndroidImportance","MAX","vibrationPattern","lightColor","isDevice","status","existingStatus","getPermissionsAsync","finalStatus","requestPermissionsAsync","console","log","getExpoPushTokenAsync","data","user","auth","getUser","savePushToken","id","userId","error","from","upsert","user_id","device_id","modelName","platform","onConflict","select","single","createNotification","title","message","type","notification","insert","userid","read","scheduleNotification","getUnreadNotifications","eq","order","ascending","markNotificationAsRead","notificationId","update","body","scheduleNotificationAsync","content","trigger"],"sources":["C:/Users/PC/TravelQuest/src/services/NotificationService.ts"],"sourcesContent":["import * as Notifications from 'expo-notifications';\r\nimport * as Device from 'expo-device';\r\nimport { Platform } from 'react-native';\r\nimport { supabase } from './supabase';\r\nimport { Notification, PushToken } from '../types/notifications';\r\n\r\n// Configurar el comportamiento de las notificaciones\r\nNotifications.setNotificationHandler({\r\n    handleNotification: async () => ({\r\n        shouldShowAlert: true,\r\n        shouldPlaySound: true,\r\n        shouldSetBadge: true,\r\n    }),\r\n});\r\n\r\nexport class NotificationService {\r\n    static async registerForPushNotificationsAsync() {\r\n        let token;\r\n\r\n        if (Platform.OS === 'android') {\r\n            await Notifications.setNotificationChannelAsync('default', {\r\n                name: 'default',\r\n                importance: Notifications.AndroidImportance.MAX,\r\n                vibrationPattern: [0, 250, 250, 250],\r\n                lightColor: '#FF231F7C',\r\n            });\r\n        }\r\n\r\n        if (Device.isDevice) {\r\n            const { status: existingStatus } = await Notifications.getPermissionsAsync();\r\n            let finalStatus = existingStatus;\r\n\r\n            if (existingStatus !== 'granted') {\r\n                const { status } = await Notifications.requestPermissionsAsync();\r\n                finalStatus = status;\r\n            }\r\n\r\n            if (finalStatus !== 'granted') {\r\n                console.log('Failed to get push token for push notification!');\r\n                return;\r\n            }\r\n\r\n            token = (await Notifications.getExpoPushTokenAsync()).data;\r\n\r\n            // Guardar el token en Supabase\r\n            const { data: { user } } = await supabase.auth.getUser();\r\n            if (user) {\r\n                await this.savePushToken(user.id, token);\r\n            }\r\n        } else {\r\n            console.log('Must use physical device for Push Notifications');\r\n        }\r\n\r\n        return token;\r\n    }\r\n\r\n    static async savePushToken(userId: string, token: string): Promise<PushToken> {\r\n        try {\r\n            const { data, error } = await supabase\r\n                .from('user_push_tokens')\r\n                .upsert({\r\n                    user_id: userId,\r\n                    token: token,\r\n                    device_id: Device.modelName,\r\n                    platform: Platform.OS\r\n                }, {\r\n                    onConflict: 'user_id,token'\r\n                })\r\n                .select()\r\n                .single();\r\n\r\n            if (error) throw error;\r\n            return data as PushToken;\r\n        } catch (error) {\r\n            console.error('Error saving push token:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    static async createNotification(userId: string, title: string, message: string, type: string, data?: any): Promise<Notification> {\r\n        try {\r\n            const { data: notification, error } = await supabase\r\n                .from('notifications')\r\n                .insert({\r\n                    userid: userId,\r\n                    title,\r\n                    message,\r\n                    type,\r\n                    data,\r\n                    read: false\r\n                })\r\n                .select()\r\n                .single();\r\n\r\n            if (error) throw error;\r\n\r\n            // También mostrar la notificación localmente\r\n            await this.scheduleNotification(title, message, data);\r\n\r\n            return notification as Notification;\r\n        } catch (error) {\r\n            console.error('Error creating notification:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    static async getUnreadNotifications(userId: string): Promise<Notification[]> {\r\n        try {\r\n            const { data, error } = await supabase\r\n                .from('notifications')\r\n                .select('*')\r\n                .eq('userid', userId)\r\n                .eq('read', false)\r\n                .order('created_at', { ascending: false });\r\n\r\n            if (error) throw error;\r\n            return data as Notification[];\r\n        } catch (error) {\r\n            console.error('Error getting unread notifications:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    static async markNotificationAsRead(notificationId: string): Promise<Notification> {\r\n        try {\r\n            const { data, error } = await supabase\r\n                .from('notifications')\r\n                .update({ read: true })\r\n                .eq('id', notificationId)\r\n                .select()\r\n                .single();\r\n\r\n            if (error) throw error;\r\n            return data as Notification;\r\n        } catch (error) {\r\n            console.error('Error marking notification as read:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    static async scheduleNotification(title: string, body: string, data: any = {}) {\r\n        await Notifications.scheduleNotificationAsync({\r\n            content: {\r\n                title,\r\n                body,\r\n                data,\r\n            },\r\n            trigger: null,\r\n        });\r\n    }\r\n} "],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}