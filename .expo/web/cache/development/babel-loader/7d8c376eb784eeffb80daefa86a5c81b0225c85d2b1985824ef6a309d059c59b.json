{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport { supabase } from \"./supabase\";\nexport var checkJournalEntriesTable = function () {\n  var _ref = _asyncToGenerator(function* () {\n    try {\n      var _yield$supabase$from$ = yield supabase.from('journal_entries').select('id').limit(1),\n        data = _yield$supabase$from$.data,\n        error = _yield$supabase$from$.error;\n      return !error;\n    } catch (error) {\n      console.error('Error verificando tabla journal_entries:', error);\n      return false;\n    }\n  });\n  return function checkJournalEntriesTable() {\n    return _ref.apply(this, arguments);\n  };\n}();\nexport var getUserJournalEntries = function () {\n  var _ref2 = _asyncToGenerator(function* (userId) {\n    try {\n      var tableExists = yield checkJournalEntriesTable();\n      if (!tableExists) {\n        console.warn('La tabla journal_entries no existe');\n        return {};\n      }\n      try {\n        var _yield$supabase$from$2 = yield supabase.from('journal_entries').select(`\n          *,\n          cities:cityId (\n            name\n          )\n        `).eq('userId', userId).order('created_at', {\n            ascending: false\n          }),\n          data = _yield$supabase$from$2.data,\n          error = _yield$supabase$from$2.error;\n        if (error) {\n          throw error;\n        }\n        return organizeCityEntries(data);\n      } catch (error) {\n        if (error.message && (error.message.includes('cityId') || error.message.includes('relationship') || error.code === 'PGRST200')) {\n          console.warn('Error con la relación cityId, obteniendo solo entradas:', error);\n          var _yield$supabase$from$3 = yield supabase.from('journal_entries').select('*').eq('userId', userId).order('created_at', {\n              ascending: false\n            }),\n            _data = _yield$supabase$from$3.data,\n            entriesError = _yield$supabase$from$3.error;\n          if (entriesError) throw entriesError;\n          return organizeCityEntries(_data, true);\n        } else {\n          throw error;\n        }\n      }\n    } catch (error) {\n      console.error('Error obteniendo entradas del diario:', error);\n      throw error;\n    }\n  });\n  return function getUserJournalEntries(_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();\nvar organizeCityEntries = function organizeCityEntries(data) {\n  var missingCityRelation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var entriesByCity = {};\n  if (!data || data.length === 0) {\n    return entriesByCity;\n  }\n  data.forEach(function (entry) {\n    var _entry$cities;\n    var cityName = 'Ciudad Desconocida';\n    if (!missingCityRelation && (_entry$cities = entry.cities) != null && _entry$cities.name) {\n      cityName = entry.cities.name;\n    } else if (entry.cityName) {\n      cityName = entry.cityName;\n    }\n    if (!entriesByCity[cityName]) {\n      entriesByCity[cityName] = [];\n    }\n    entriesByCity[cityName].push(_objectSpread(_objectSpread({}, entry), {}, {\n      city_name: cityName\n    }));\n  });\n  return entriesByCity;\n};\nexport var getMissionJournalEntries = function () {\n  var _ref3 = _asyncToGenerator(function* (userId, missionId) {\n    try {\n      var tableExists = yield checkJournalEntriesTable();\n      if (!tableExists) {\n        console.warn('La tabla journal_entries no existe');\n        return [];\n      }\n      try {\n        var _yield$supabase$from$4 = yield supabase.from('journal_entries').select(`\n          *,\n          cities:cityId (\n            name\n          )\n        `).eq('userId', userId).eq('missionId', missionId).order('created_at', {\n            ascending: false\n          }),\n          data = _yield$supabase$from$4.data,\n          error = _yield$supabase$from$4.error;\n        if (error) throw error;\n        if (!data) return [];\n        return data.map(function (entry) {\n          var _entry$cities2;\n          return _objectSpread(_objectSpread({}, entry), {}, {\n            city_name: ((_entry$cities2 = entry.cities) == null ? void 0 : _entry$cities2.name) || 'Ciudad Desconocida'\n          });\n        });\n      } catch (error) {\n        if (error.message && (error.message.includes('cityId') || error.message.includes('relationship') || error.code === 'PGRST200')) {\n          console.warn('Error con la relación cityId, obteniendo solo entradas:', error);\n          var _yield$supabase$from$5 = yield supabase.from('journal_entries').select('*').eq('userId', userId).eq('missionId', missionId).order('created_at', {\n              ascending: false\n            }),\n            _data2 = _yield$supabase$from$5.data,\n            entriesError = _yield$supabase$from$5.error;\n          if (entriesError) throw entriesError;\n          if (!_data2) return [];\n          return _data2.map(function (entry) {\n            return _objectSpread(_objectSpread({}, entry), {}, {\n              city_name: entry.cityName || 'Ciudad Desconocida'\n            });\n          });\n        } else {\n          throw error;\n        }\n      }\n    } catch (error) {\n      console.error('Error obteniendo entradas de la misión:', error);\n      throw error;\n    }\n  });\n  return function getMissionJournalEntries(_x2, _x3) {\n    return _ref3.apply(this, arguments);\n  };\n}();","map":{"version":3,"names":["supabase","checkJournalEntriesTable","_ref","_asyncToGenerator","_yield$supabase$from$","from","select","limit","data","error","console","apply","arguments","getUserJournalEntries","_ref2","userId","tableExists","warn","_yield$supabase$from$2","eq","order","ascending","organizeCityEntries","message","includes","code","_yield$supabase$from$3","entriesError","_x","missingCityRelation","length","undefined","entriesByCity","forEach","entry","_entry$cities","cityName","cities","name","push","_objectSpread","city_name","getMissionJournalEntries","_ref3","missionId","_yield$supabase$from$4","map","_entry$cities2","_yield$supabase$from$5","_x2","_x3"],"sources":["C:/Users/migue/TravelQuest/src/services/journalService.ts"],"sourcesContent":["import { supabase } from './supabase';\r\n\r\nexport interface JournalEntryDB {\r\n  id: string;\r\n  userId: string;\r\n  cityId: string;\r\n  missionId?: string;\r\n  title: string;\r\n  content: string;\r\n  photos: string[];\r\n  location: {\r\n    latitude: number;\r\n    longitude: number;\r\n  } | null;\r\n  created_at: string;\r\n  tags: string[];\r\n}\r\n\r\nexport interface CityJournalEntry extends JournalEntryDB {\r\n  city_name: string;\r\n}\r\n\r\n/**\r\n * Verifica si existe la tabla journal_entries en la base de datos\r\n * @returns true si la tabla existe, false en caso contrario\r\n */\r\nexport const checkJournalEntriesTable = async (): Promise<boolean> => {\r\n  try {\r\n    // Probamos si la tabla existe obteniendo solo una fila\r\n    const { data, error } = await supabase\r\n      .from('journal_entries')\r\n      .select('id')\r\n      .limit(1);\r\n    \r\n    // Si no hay error, la tabla existe\r\n    return !error;\r\n  } catch (error) {\r\n    console.error('Error verificando tabla journal_entries:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Obtiene todas las entradas del diario del usuario agrupadas por ciudad\r\n * @param userId ID del usuario \r\n * @returns Entradas del diario agrupadas por ciudad\r\n */\r\nexport const getUserJournalEntries = async (userId: string): Promise<{ [cityName: string]: CityJournalEntry[] }> => {\r\n  try {\r\n    // Verificar si la tabla existe\r\n    const tableExists = await checkJournalEntriesTable();\r\n    if (!tableExists) {\r\n      console.warn('La tabla journal_entries no existe');\r\n      return {}; // Devolvemos un objeto vacío\r\n    }\r\n\r\n    // Primero intentamos con la relación cityId a cities\r\n    try {\r\n      // Obtener todas las entradas del diario del usuario con el nombre de la ciudad\r\n      const { data, error } = await supabase\r\n        .from('journal_entries')\r\n        .select(`\r\n          *,\r\n          cities:cityId (\r\n            name\r\n          )\r\n        `)\r\n        .eq('userId', userId)\r\n        .order('created_at', { ascending: false });\r\n\r\n      if (error) {\r\n        throw error;\r\n      }\r\n\r\n      // Organizar las entradas por ciudad\r\n      return organizeCityEntries(data);\r\n    } catch (error: any) {\r\n      // Si hay un error con la relación, intentamos obtener solo las entradas\r\n      if (error.message && (\r\n          error.message.includes('cityId') || \r\n          error.message.includes('relationship') ||\r\n          error.code === 'PGRST200')) {\r\n            \r\n        console.warn('Error con la relación cityId, obteniendo solo entradas:', error);\r\n        \r\n        const { data, error: entriesError } = await supabase\r\n          .from('journal_entries')\r\n          .select('*')\r\n          .eq('userId', userId)\r\n          .order('created_at', { ascending: false });\r\n        \r\n        if (entriesError) throw entriesError;\r\n        \r\n        // Organizar las entradas sin nombre de ciudad\r\n        return organizeCityEntries(data, true);\r\n      } else {\r\n        throw error;\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.error('Error obteniendo entradas del diario:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Organiza las entradas del diario por ciudad\r\n * @param data Datos de las entradas\r\n * @param missingCityRelation Indica si falta la relación con la ciudad\r\n * @returns Entradas organizadas por ciudad\r\n */\r\nconst organizeCityEntries = (\r\n  data: any[] | null, \r\n  missingCityRelation: boolean = false\r\n): { [cityName: string]: CityJournalEntry[] } => {\r\n  const entriesByCity: { [cityName: string]: CityJournalEntry[] } = {};\r\n  \r\n  if (!data || data.length === 0) {\r\n    return entriesByCity;\r\n  }\r\n  \r\n  data.forEach((entry: any) => {\r\n    let cityName = 'Ciudad Desconocida';\r\n    \r\n    if (!missingCityRelation && entry.cities?.name) {\r\n      cityName = entry.cities.name;\r\n    } else if (entry.cityName) {\r\n      cityName = entry.cityName;\r\n    }\r\n    \r\n    if (!entriesByCity[cityName]) {\r\n      entriesByCity[cityName] = [];\r\n    }\r\n    \r\n    entriesByCity[cityName].push({\r\n      ...entry,\r\n      city_name: cityName\r\n    });\r\n  });\r\n\r\n  return entriesByCity;\r\n};\r\n\r\n/**\r\n * Obtiene las entradas del diario relacionadas con una misión específica\r\n * @param userId ID del usuario\r\n * @param missionId ID de la misión\r\n * @returns Entradas del diario relacionadas con la misión\r\n */\r\nexport const getMissionJournalEntries = async (userId: string, missionId: string): Promise<CityJournalEntry[]> => {\r\n  try {\r\n    // Verificar si la tabla existe\r\n    const tableExists = await checkJournalEntriesTable();\r\n    if (!tableExists) {\r\n      console.warn('La tabla journal_entries no existe');\r\n      return []; // Devolvemos un array vacío\r\n    }\r\n\r\n    // Primero intentamos con la relación cityId a cities\r\n    try {\r\n      const { data, error } = await supabase\r\n        .from('journal_entries')\r\n        .select(`\r\n          *,\r\n          cities:cityId (\r\n            name\r\n          )\r\n        `)\r\n        .eq('userId', userId)\r\n        .eq('missionId', missionId)\r\n        .order('created_at', { ascending: false });\r\n\r\n      if (error) throw error;\r\n\r\n      if (!data) return [];\r\n      \r\n      return data.map((entry: any) => ({\r\n        ...entry,\r\n        city_name: entry.cities?.name || 'Ciudad Desconocida'\r\n      }));\r\n    } catch (error: any) {\r\n      // Si hay un error con la relación, intentamos obtener solo las entradas\r\n      if (error.message && (\r\n          error.message.includes('cityId') || \r\n          error.message.includes('relationship') ||\r\n          error.code === 'PGRST200')) {\r\n            \r\n        console.warn('Error con la relación cityId, obteniendo solo entradas:', error);\r\n        \r\n        const { data, error: entriesError } = await supabase\r\n          .from('journal_entries')\r\n          .select('*')\r\n          .eq('userId', userId)\r\n          .eq('missionId', missionId)\r\n          .order('created_at', { ascending: false });\r\n        \r\n        if (entriesError) throw entriesError;\r\n        \r\n        if (!data) return [];\r\n        \r\n        return data.map((entry: any) => ({\r\n          ...entry,\r\n          city_name: entry.cityName || 'Ciudad Desconocida'\r\n        }));\r\n      } else {\r\n        throw error;\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.error('Error obteniendo entradas de la misión:', error);\r\n    throw error;\r\n  }\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}