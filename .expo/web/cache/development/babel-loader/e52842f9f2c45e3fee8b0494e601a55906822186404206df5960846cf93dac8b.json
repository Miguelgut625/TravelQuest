{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport { supabase } from \"./supabase\";\nvar _require = require(\"@google/generative-ai\"),\n  GoogleGenerativeAI = _require.GoogleGenerativeAI;\nvar genAI = new GoogleGenerativeAI(\"AIzaSyB4PuDOYXgbH9egme1UCO0CiRcOV4kVfMM\");\nvar getOrCreateCity = function () {\n  var _ref = _asyncToGenerator(function* (cityName) {\n    try {\n      var _yield$supabase$from$ = yield supabase.from('cities').select('id').eq('name', cityName).single(),\n        existingCity = _yield$supabase$from$.data,\n        searchError = _yield$supabase$from$.error;\n      if (searchError && searchError.code !== 'PGRST116') {\n        throw searchError;\n      }\n      if (existingCity) {\n        return existingCity.id;\n      }\n      var _yield$supabase$from$2 = yield supabase.from('cities').insert([{\n          name: cityName\n        }]).select('id').single(),\n        newCity = _yield$supabase$from$2.data,\n        insertError = _yield$supabase$from$2.error;\n      if (insertError) throw insertError;\n      return newCity.id;\n    } catch (error) {\n      console.error('Error al obtener/crear la ciudad:', error);\n      throw error;\n    }\n  });\n  return function getOrCreateCity(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\nvar getExistingChallenges = function () {\n  var _ref2 = _asyncToGenerator(function* (cityId, count, userId) {\n    try {\n      var _yield$supabase$from$3 = yield supabase.from('challenges').select('*').eq('cityId', cityId),\n        challenges = _yield$supabase$from$3.data,\n        error = _yield$supabase$from$3.error;\n      if (error) throw error;\n      if (!challenges || challenges.length === 0) {\n        return null;\n      }\n      var _yield$supabase$from$4 = yield supabase.from('journeys').select('id').eq('userId', userId),\n        userJourneys = _yield$supabase$from$4.data,\n        journeysError = _yield$supabase$from$4.error;\n      if (journeysError) throw journeysError;\n      if (!userJourneys || userJourneys.length === 0) {\n        if (challenges.length >= 10) {\n          var shuffled = challenges.sort(function () {\n            return 0.5 - Math.random();\n          });\n          return shuffled.slice(0, count);\n        }\n        return null;\n      }\n      var _yield$supabase$from$5 = yield supabase.from('journeys_missions').select('challengeId').in('journeyId', userJourneys.map(function (j) {\n          return j.id;\n        })).in('challengeId', challenges.map(function (c) {\n          return c.id;\n        })),\n        userChallenges = _yield$supabase$from$5.data,\n        userError = _yield$supabase$from$5.error;\n      if (userError) throw userError;\n      var userChallengeIds = new Set((userChallenges == null ? void 0 : userChallenges.map(function (uc) {\n        return uc.challengeId;\n      })) || []);\n      var availableChallenges = challenges.filter(function (c) {\n        return !userChallengeIds.has(c.id);\n      });\n      if (availableChallenges.length >= 10) {\n        var _shuffled = availableChallenges.sort(function () {\n          return 0.5 - Math.random();\n        });\n        return _shuffled.slice(0, count);\n      }\n      return null;\n    } catch (error) {\n      console.error('Error obteniendo desafíos existentes:', error);\n      throw error;\n    }\n  });\n  return function getExistingChallenges(_x2, _x3, _x4) {\n    return _ref2.apply(this, arguments);\n  };\n}();\nvar generateMission = function () {\n  var _ref3 = _asyncToGenerator(function* (cityName, duration, missionCount, userId) {\n    try {\n      var cityId = yield getOrCreateCity(cityName);\n      var _yield$supabase$from$6 = yield supabase.from('journeys').insert([{\n          userId: userId,\n          cityId: cityId,\n          description: `Viaje a ${cityName} por ${duration} días`\n        }]).select('id').single(),\n        journey = _yield$supabase$from$6.data,\n        journeyError = _yield$supabase$from$6.error;\n      if (journeyError) throw journeyError;\n      var existingChallenges = yield getExistingChallenges(cityId, missionCount, userId);\n      var challenges;\n      if (existingChallenges && existingChallenges.length > 0) {\n        console.log('Usando desafíos existentes');\n        challenges = existingChallenges;\n      } else {\n        console.log('Generando nuevos desafíos');\n        var model = genAI.getGenerativeModel({\n          model: \"gemini-1.5-flash\"\n        });\n        var prompt = `Genera ${missionCount} misiones en ${cityName} que se puedan completar en ${duration} días. Devuelve un objeto JSON con la siguiente estructura exacta:\n{\n  \"misiones\": [\n    {\n      \"Título\": \"Título de la misión\",\n      \"Descripción\": \"Descripción detallada de la misión incluyendo qué foto tomar\",\n      \"Dificultad\": \"Fácil|Media|Difícil\",\n      \"Puntos\": 25|50|100\n    }\n  ]\n}\nLos puntos deben ser: 25 para Fácil, 50 para Media, 100 para Difícil. No incluyas explicaciones adicionales, solo el JSON.`;\n        var result = yield model.generateContent(prompt);\n        var response = yield result.response;\n        var missionsData = response.text();\n        console.log('Respuesta de la API:', missionsData);\n        var jsonMatch = missionsData.match(/\\{[\\s\\S]*\\}/);\n        if (!jsonMatch) {\n          throw new Error('No se encontró un objeto JSON válido en la respuesta');\n        }\n        var missions = JSON.parse(jsonMatch[0]);\n        if (!missions.misiones || !Array.isArray(missions.misiones)) {\n          throw new Error('La respuesta no contiene un array de misiones válido');\n        }\n        var formattedChallenges = missions.misiones.map(function (mission) {\n          return {\n            title: mission.Título,\n            description: mission.Descripción,\n            cityId: cityId,\n            duration: duration,\n            difficulty: mission.Dificultad,\n            points: mission.Puntos\n          };\n        });\n        var _yield$supabase$from$7 = yield supabase.from('challenges').insert(formattedChallenges).select('id'),\n          newChallenges = _yield$supabase$from$7.data,\n          challengesError = _yield$supabase$from$7.error;\n        if (challengesError) throw challengesError;\n        challenges = newChallenges;\n      }\n      var journeyMissions = challenges.map(function (challenge) {\n        return {\n          journeyId: journey.id,\n          challengeId: challenge.id,\n          completed: false\n        };\n      });\n      var _yield$supabase$from$8 = yield supabase.from('journeys_missions').insert(journeyMissions),\n        linkError = _yield$supabase$from$8.error;\n      if (linkError) throw linkError;\n      console.log('Journey y desafíos creados exitosamente');\n      return {\n        journeyId: journey.id,\n        challenges: challenges\n      };\n    } catch (error) {\n      console.error('Error generando desafíos:', error);\n      throw error;\n    }\n  });\n  return function generateMission(_x5, _x6, _x7, _x8) {\n    return _ref3.apply(this, arguments);\n  };\n}();\nexport default generateMission;","map":{"version":3,"names":["supabase","_require","require","GoogleGenerativeAI","genAI","getOrCreateCity","_ref","_asyncToGenerator","cityName","_yield$supabase$from$","from","select","eq","single","existingCity","data","searchError","error","code","id","_yield$supabase$from$2","insert","name","newCity","insertError","console","_x","apply","arguments","getExistingChallenges","_ref2","cityId","count","userId","_yield$supabase$from$3","challenges","length","_yield$supabase$from$4","userJourneys","journeysError","shuffled","sort","Math","random","slice","_yield$supabase$from$5","in","map","j","c","userChallenges","userError","userChallengeIds","Set","uc","challengeId","availableChallenges","filter","has","_x2","_x3","_x4","generateMission","_ref3","duration","missionCount","_yield$supabase$from$6","description","journey","journeyError","existingChallenges","log","model","getGenerativeModel","prompt","result","generateContent","response","missionsData","text","jsonMatch","match","Error","missions","JSON","parse","misiones","Array","isArray","formattedChallenges","mission","title","Título","Descripción","difficulty","Dificultad","points","Puntos","_yield$supabase$from$7","newChallenges","challengesError","journeyMissions","challenge","journeyId","completed","_yield$supabase$from$8","linkError","_x5","_x6","_x7","_x8"],"sources":["C:/Users/migue/miguel/TravelQuest/src/services/missionGenerator.ts"],"sourcesContent":["import { supabase } from './supabase';\r\nconst { GoogleGenerativeAI } = require(\"@google/generative-ai\");\r\n\r\n// Accede a tu clave de API como una variable de entorno\r\nconst genAI = new GoogleGenerativeAI(\"AIzaSyB4PuDOYXgbH9egme1UCO0CiRcOV4kVfMM\");\r\n\r\n// Interfaces para los tipos de datos\r\ninterface Challenge {\r\n  id: string;\r\n}\r\n\r\ninterface UserChallenge {\r\n  challengeId: string;\r\n}\r\n\r\ninterface Journey {\r\n  id: string;\r\n}\r\n\r\n// Función para obtener o crear una ciudad\r\nconst getOrCreateCity = async (cityName: string) => {\r\n  try {\r\n    // Primero intentamos encontrar la ciudad\r\n    const { data: existingCity, error: searchError } = await supabase\r\n      .from('cities')\r\n      .select('id')\r\n      .eq('name', cityName)\r\n      .single();\r\n\r\n    if (searchError && searchError.code !== 'PGRST116') { // PGRST116 es el código para \"no se encontraron resultados\"\r\n      throw searchError;\r\n    }\r\n\r\n    if (existingCity) {\r\n      return existingCity.id;\r\n    }\r\n\r\n    // Si no existe la ciudad, la creamos\r\n    const { data: newCity, error: insertError } = await supabase\r\n      .from('cities')\r\n      .insert([{ name: cityName }])\r\n      .select('id')\r\n      .single();\r\n\r\n    if (insertError) throw insertError;\r\n    \r\n    return newCity.id;\r\n  } catch (error) {\r\n    console.error('Error al obtener/crear la ciudad:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Función para obtener desafíos existentes de una ciudad que el usuario no haya solicitado\r\nconst getExistingChallenges = async (cityId: string, count: number, userId: string) => {\r\n  try {\r\n    // Primero obtenemos todos los desafíos de la ciudad\r\n    const { data: challenges, error } = await supabase\r\n      .from('challenges')\r\n      .select('*') // Seleccionar todos los campos, no solo el id\r\n      .eq('cityId', cityId);\r\n\r\n    if (error) throw error;\r\n\r\n    if (!challenges || challenges.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    // Obtener los desafíos que el usuario ya ha solicitado\r\n    // Primero obtenemos los journeys del usuario\r\n    const { data: userJourneys, error: journeysError } = await supabase\r\n      .from('journeys')\r\n      .select('id')\r\n      .eq('userId', userId);\r\n\r\n    if (journeysError) throw journeysError;\r\n\r\n    if (!userJourneys || userJourneys.length === 0) {\r\n      // Si el usuario no tiene journeys, seleccionar aleatoriamente la cantidad solicitada\r\n      if (challenges.length >= 10) {\r\n        const shuffled = challenges.sort(() => 0.5 - Math.random());\r\n        return shuffled.slice(0, count);\r\n      }\r\n      return null;\r\n    }\r\n\r\n    // Luego obtenemos los desafíos asociados a esos journeys\r\n    const { data: userChallenges, error: userError } = await supabase\r\n      .from('journeys_missions')\r\n      .select('challengeId')\r\n      .in('journeyId', userJourneys.map((j: Journey) => j.id))\r\n      .in('challengeId', challenges.map((c: Challenge) => c.id));\r\n\r\n    if (userError) throw userError;\r\n\r\n    // Filtrar los desafíos que el usuario ya ha solicitado\r\n    const userChallengeIds = new Set(userChallenges?.map((uc: UserChallenge) => uc.challengeId) || []);\r\n    const availableChallenges = challenges.filter((c: Challenge) => !userChallengeIds.has(c.id));\r\n\r\n    // Si hay suficientes desafíos disponibles (10 o más)\r\n    if (availableChallenges.length >= 10) {\r\n      // Mezclar el array de desafíos disponibles\r\n      const shuffled = availableChallenges.sort(() => 0.5 - Math.random());\r\n      // Tomar solo la cantidad solicitada\r\n      return shuffled.slice(0, count);\r\n    }\r\n\r\n    return null; // Retornar null si no hay suficientes desafíos disponibles\r\n  } catch (error) {\r\n    console.error('Error obteniendo desafíos existentes:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\nconst generateMission = async (cityName: string, duration: number, missionCount: number, userId: string) => {\r\n  try {\r\n    // Obtener o crear la ciudad\r\n    const cityId = await getOrCreateCity(cityName);\r\n\r\n    // Crear un nuevo journey\r\n    const { data: journey, error: journeyError } = await supabase\r\n      .from('journeys')\r\n      .insert([{\r\n        userId,\r\n        cityId,\r\n        description: `Viaje a ${cityName} por ${duration} días`\r\n      }])\r\n      .select('id')\r\n      .single();\r\n\r\n    if (journeyError) throw journeyError;\r\n\r\n    // Verificar si hay suficientes desafíos existentes que el usuario no haya solicitado\r\n    const existingChallenges = await getExistingChallenges(cityId, missionCount, userId);\r\n\r\n    let challenges;\r\n    if (existingChallenges && existingChallenges.length > 0) {\r\n      // Usar desafíos existentes\r\n      console.log('Usando desafíos existentes');\r\n      challenges = existingChallenges;\r\n    } else {\r\n      // Solo generar nuevos desafíos si no hay suficientes existentes\r\n      console.log('Generando nuevos desafíos');\r\n      // Generar nuevos desafíos\r\n      const model = genAI.getGenerativeModel({ model: \"gemini-1.5-flash\" });\r\n\r\n      const prompt = `Genera ${missionCount} misiones en ${cityName} que se puedan completar en ${duration} días. Devuelve un objeto JSON con la siguiente estructura exacta:\r\n{\r\n  \"misiones\": [\r\n    {\r\n      \"Título\": \"Título de la misión\",\r\n      \"Descripción\": \"Descripción detallada de la misión incluyendo qué foto tomar\",\r\n      \"Dificultad\": \"Fácil|Media|Difícil\",\r\n      \"Puntos\": 25|50|100\r\n    }\r\n  ]\r\n}\r\nLos puntos deben ser: 25 para Fácil, 50 para Media, 100 para Difícil. No incluyas explicaciones adicionales, solo el JSON.`;\r\n\r\n      const result = await model.generateContent(prompt);\r\n      const response = await result.response;\r\n      const missionsData = response.text();\r\n\r\n      console.log('Respuesta de la API:', missionsData);\r\n\r\n      const jsonMatch = missionsData.match(/\\{[\\s\\S]*\\}/);\r\n      if (!jsonMatch) {\r\n        throw new Error('No se encontró un objeto JSON válido en la respuesta');\r\n      }\r\n\r\n      const missions = JSON.parse(jsonMatch[0]);\r\n\r\n      if (!missions.misiones || !Array.isArray(missions.misiones)) {\r\n        throw new Error('La respuesta no contiene un array de misiones válido');\r\n      }\r\n\r\n      // Crear los desafíos\r\n      const formattedChallenges = missions.misiones.map((mission: any) => ({\r\n        title: mission.Título,\r\n        description: mission.Descripción,\r\n        cityId,\r\n        duration,\r\n        difficulty: mission.Dificultad,\r\n        points: mission.Puntos\r\n      }));\r\n\r\n      const { data: newChallenges, error: challengesError } = await supabase\r\n        .from('challenges')\r\n        .insert(formattedChallenges)\r\n        .select('id');\r\n\r\n      if (challengesError) throw challengesError;\r\n      \r\n      challenges = newChallenges;\r\n    }\r\n\r\n    // Vincular los desafíos al journey\r\n    const journeyMissions = challenges.map((challenge: { id: string }) => ({\r\n      journeyId: journey.id,\r\n      challengeId: challenge.id,\r\n      completed: false\r\n    }));\r\n\r\n    const { error: linkError } = await supabase\r\n      .from('journeys_missions')\r\n      .insert(journeyMissions);\r\n\r\n    if (linkError) throw linkError;\r\n\r\n    console.log('Journey y desafíos creados exitosamente');\r\n    return { journeyId: journey.id, challenges };\r\n  } catch (error) {\r\n    console.error('Error generando desafíos:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n\r\nexport default generateMission;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}