{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport { supabase } from \"./supabase\";\nexport var sendMessage = function () {\n  var _ref = _asyncToGenerator(function* (senderId, receiverId, content) {\n    try {\n      var _yield$supabase$from$ = yield supabase.from('messages').insert({\n          sender_id: senderId,\n          receiver_id: receiverId,\n          content: content,\n          created_at: new Date().toISOString(),\n          read: false\n        }).select().single(),\n        data = _yield$supabase$from$.data,\n        error = _yield$supabase$from$.error;\n      if (error) {\n        console.error('Error enviando mensaje:', error);\n        return null;\n      }\n      return data;\n    } catch (error) {\n      console.error('Error inesperado enviando mensaje:', error);\n      return null;\n    }\n  });\n  return function sendMessage(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\nexport var getConversation = function () {\n  var _ref2 = _asyncToGenerator(function* (userId1, userId2) {\n    try {\n      var _yield$supabase$from$2 = yield supabase.from('messages').select('*').or(`and(sender_id.eq.${userId1},receiver_id.eq.${userId2}),and(sender_id.eq.${userId2},receiver_id.eq.${userId1})`).order('created_at', {\n          ascending: true\n        }),\n        data = _yield$supabase$from$2.data,\n        error = _yield$supabase$from$2.error;\n      if (error) {\n        console.error('Error obteniendo conversación:', error);\n        return [];\n      }\n      return data || [];\n    } catch (error) {\n      console.error('Error inesperado obteniendo conversación:', error);\n      return [];\n    }\n  });\n  return function getConversation(_x4, _x5) {\n    return _ref2.apply(this, arguments);\n  };\n}();\nexport var markMessagesAsRead = function () {\n  var _ref3 = _asyncToGenerator(function* (receiverId, senderId) {\n    try {\n      var _yield$supabase$from$3 = yield supabase.from('messages').update({\n          read: true\n        }).eq('receiver_id', receiverId).eq('sender_id', senderId).eq('read', false),\n        error = _yield$supabase$from$3.error;\n      if (error) {\n        console.error('Error marcando mensajes como leídos:', error);\n      }\n    } catch (error) {\n      console.error('Error inesperado marcando mensajes como leídos:', error);\n    }\n  });\n  return function markMessagesAsRead(_x6, _x7) {\n    return _ref3.apply(this, arguments);\n  };\n}();\nexport var subscribeToMessages = function subscribeToMessages(userId, onNewMessage, friendId) {\n  if (friendId) {\n    return supabase.channel(`messages-channel-${userId}-${friendId}`).on('postgres_changes', {\n      event: 'INSERT',\n      schema: 'public',\n      table: 'messages',\n      filter: `and(or(sender_id.eq.${userId},sender_id.eq.${friendId}),or(receiver_id.eq.${userId},receiver_id.eq.${friendId}))`\n    }, function (payload) {\n      var newMsg = payload.new;\n      if (newMsg.sender_id === userId && newMsg.receiver_id === friendId || newMsg.sender_id === friendId && newMsg.receiver_id === userId) {\n        console.log('Nuevo mensaje en conversación específica:', newMsg);\n        onNewMessage(newMsg);\n      }\n    }).subscribe();\n  }\n  return supabase.channel(`messages-channel-${userId}`).on('postgres_changes', {\n    event: 'INSERT',\n    schema: 'public',\n    table: 'messages',\n    filter: `receiver_id=eq.${userId}`\n  }, function (payload) {\n    console.log('Nuevo mensaje recibido:', payload.new);\n    onNewMessage(payload.new);\n  }).subscribe();\n};\nexport var getRecentConversations = function () {\n  var _ref4 = _asyncToGenerator(function* (userId) {\n    try {\n      var _yield$supabase$rpc = yield supabase.rpc('get_recent_conversations', {\n          user_id: userId\n        }),\n        data = _yield$supabase$rpc.data,\n        error = _yield$supabase$rpc.error;\n      if (error) {\n        console.error('Error obteniendo conversaciones recientes:', error);\n        return [];\n      }\n      return data || [];\n    } catch (error) {\n      console.error('Error inesperado obteniendo conversaciones recientes:', error);\n      return [];\n    }\n  });\n  return function getRecentConversations(_x8) {\n    return _ref4.apply(this, arguments);\n  };\n}();\nexport var countUnreadMessages = function () {\n  var _ref5 = _asyncToGenerator(function* (userId) {\n    try {\n      var _yield$supabase$from$4 = yield supabase.from('messages').select('*', {\n          count: 'exact',\n          head: true\n        }).eq('receiver_id', userId).eq('read', false),\n        count = _yield$supabase$from$4.count,\n        error = _yield$supabase$from$4.error;\n      if (error) {\n        console.error('Error contando mensajes no leídos:', error);\n        return 0;\n      }\n      return count || 0;\n    } catch (error) {\n      console.error('Error inesperado contando mensajes no leídos:', error);\n      return 0;\n    }\n  });\n  return function countUnreadMessages(_x9) {\n    return _ref5.apply(this, arguments);\n  };\n}();","map":{"version":3,"names":["supabase","sendMessage","_ref","_asyncToGenerator","senderId","receiverId","content","_yield$supabase$from$","from","insert","sender_id","receiver_id","created_at","Date","toISOString","read","select","single","data","error","console","_x","_x2","_x3","apply","arguments","getConversation","_ref2","userId1","userId2","_yield$supabase$from$2","or","order","ascending","_x4","_x5","markMessagesAsRead","_ref3","_yield$supabase$from$3","update","eq","_x6","_x7","subscribeToMessages","userId","onNewMessage","friendId","channel","on","event","schema","table","filter","payload","newMsg","new","log","subscribe","getRecentConversations","_ref4","_yield$supabase$rpc","rpc","user_id","_x8","countUnreadMessages","_ref5","_yield$supabase$from$4","count","head","_x9"],"sources":["C:/Users/migue/TravelQuest/src/services/messageService.ts"],"sourcesContent":["import { supabase } from './supabase';\r\n\r\nexport interface Message {\r\n  id: string;\r\n  sender_id: string;\r\n  receiver_id: string;\r\n  content: string;\r\n  created_at: string;\r\n  read: boolean;\r\n}\r\n\r\n// Función para enviar un mensaje\r\nexport const sendMessage = async (senderId: string, receiverId: string, content: string): Promise<Message | null> => {\r\n  try {\r\n    const { data, error } = await supabase\r\n      .from('messages')\r\n      .insert({\r\n        sender_id: senderId,\r\n        receiver_id: receiverId,\r\n        content,\r\n        created_at: new Date().toISOString(),\r\n        read: false\r\n      })\r\n      .select()\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error('Error enviando mensaje:', error);\r\n      return null;\r\n    }\r\n\r\n    return data;\r\n  } catch (error) {\r\n    console.error('Error inesperado enviando mensaje:', error);\r\n    return null;\r\n  }\r\n};\r\n\r\n// Función para obtener los mensajes entre dos usuarios\r\nexport const getConversation = async (userId1: string, userId2: string): Promise<Message[]> => {\r\n  try {\r\n    const { data, error } = await supabase\r\n      .from('messages')\r\n      .select('*')\r\n      .or(`and(sender_id.eq.${userId1},receiver_id.eq.${userId2}),and(sender_id.eq.${userId2},receiver_id.eq.${userId1})`)\r\n      .order('created_at', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error obteniendo conversación:', error);\r\n      return [];\r\n    }\r\n\r\n    return data || [];\r\n  } catch (error) {\r\n    console.error('Error inesperado obteniendo conversación:', error);\r\n    return [];\r\n  }\r\n};\r\n\r\n// Función para marcar mensajes como leídos\r\nexport const markMessagesAsRead = async (receiverId: string, senderId: string): Promise<void> => {\r\n  try {\r\n    const { error } = await supabase\r\n      .from('messages')\r\n      .update({ read: true })\r\n      .eq('receiver_id', receiverId)\r\n      .eq('sender_id', senderId)\r\n      .eq('read', false);\r\n\r\n    if (error) {\r\n      console.error('Error marcando mensajes como leídos:', error);\r\n    }\r\n  } catch (error) {\r\n    console.error('Error inesperado marcando mensajes como leídos:', error);\r\n  }\r\n};\r\n\r\n// Función para suscribirse a nuevos mensajes\r\nexport const subscribeToMessages = (\r\n  userId: string,\r\n  onNewMessage: (message: Message) => void,\r\n  friendId?: string\r\n) => {\r\n  // Si tenemos un friendId, nos suscribimos a mensajes entre dos usuarios específicos\r\n  if (friendId) {\r\n    return supabase\r\n      .channel(`messages-channel-${userId}-${friendId}`)\r\n      .on(\r\n        'postgres_changes',\r\n        {\r\n          event: 'INSERT',\r\n          schema: 'public',\r\n          table: 'messages',\r\n          filter: `and(or(sender_id.eq.${userId},sender_id.eq.${friendId}),or(receiver_id.eq.${userId},receiver_id.eq.${friendId}))`,\r\n        },\r\n        (payload: { new: Message }) => {\r\n          // Verificar que el mensaje es parte de la conversación entre estos dos usuarios\r\n          const newMsg = payload.new;\r\n          if (\r\n            (newMsg.sender_id === userId && newMsg.receiver_id === friendId) ||\r\n            (newMsg.sender_id === friendId && newMsg.receiver_id === userId)\r\n          ) {\r\n            console.log('Nuevo mensaje en conversación específica:', newMsg);\r\n            onNewMessage(newMsg);\r\n          }\r\n        }\r\n      )\r\n      .subscribe();\r\n  }\r\n\r\n  // Suscripción general a todos los mensajes donde el usuario es receptor\r\n  return supabase\r\n    .channel(`messages-channel-${userId}`)\r\n    .on(\r\n      'postgres_changes',\r\n      {\r\n        event: 'INSERT',\r\n        schema: 'public',\r\n        table: 'messages',\r\n        filter: `receiver_id=eq.${userId}`,\r\n      },\r\n      (payload: { new: Message }) => {\r\n        console.log('Nuevo mensaje recibido:', payload.new);\r\n        onNewMessage(payload.new);\r\n      }\r\n    )\r\n    .subscribe();\r\n};\r\n\r\n// Función para obtener las conversaciones recientes\r\nexport const getRecentConversations = async (userId: string) => {\r\n  try {\r\n    // Obtenemos los mensajes más recientes para cada conversación\r\n    const { data, error } = await supabase\r\n      .rpc('get_recent_conversations', {\r\n        user_id: userId\r\n      });\r\n\r\n    if (error) {\r\n      console.error('Error obteniendo conversaciones recientes:', error);\r\n      return [];\r\n    }\r\n\r\n    return data || [];\r\n  } catch (error) {\r\n    console.error('Error inesperado obteniendo conversaciones recientes:', error);\r\n    return [];\r\n  }\r\n};\r\n\r\n// Función para contar mensajes no leídos\r\nexport const countUnreadMessages = async (userId: string): Promise<number> => {\r\n  try {\r\n    const { count, error } = await supabase\r\n      .from('messages')\r\n      .select('*', { count: 'exact', head: true })\r\n      .eq('receiver_id', userId)\r\n      .eq('read', false);\r\n\r\n    if (error) {\r\n      console.error('Error contando mensajes no leídos:', error);\r\n      return 0;\r\n    }\r\n\r\n    return count || 0;\r\n  } catch (error) {\r\n    console.error('Error inesperado contando mensajes no leídos:', error);\r\n    return 0;\r\n  }\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}