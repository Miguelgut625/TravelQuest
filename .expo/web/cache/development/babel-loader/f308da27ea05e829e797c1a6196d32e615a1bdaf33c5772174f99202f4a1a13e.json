{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nimport { Platform } from 'expo-modules-core';\nimport path from 'path-browserify';\nimport PixelRatio from \"react-native-web/dist/exports/PixelRatio\";\nimport URL from 'url-parse';\nimport AssetSourceResolver from \"./AssetSourceResolver\";\nimport { getManifest, getManifest2, manifestBaseUrl } from \"./PlatformUtils\";\nvar assetMapOverride = getManifest().assetMapOverride;\nexport function selectAssetSource(meta) {\n  var _manifest2$extra;\n  if (assetMapOverride && assetMapOverride.hasOwnProperty(meta.hash)) {\n    meta = _objectSpread(_objectSpread({}, meta), assetMapOverride[meta.hash]);\n  }\n  var scale = AssetSourceResolver.pickScale(meta.scales, PixelRatio.get());\n  var index = meta.scales.findIndex(function (s) {\n    return s === scale;\n  });\n  var hash = meta.fileHashes ? meta.fileHashes[index] || meta.fileHashes[0] : meta.hash;\n  var uri = meta.fileUris ? meta.fileUris[index] || meta.fileUris[0] : meta.uri;\n  if (uri) {\n    return {\n      uri: resolveUri(uri),\n      hash: hash\n    };\n  }\n  var assetUrlOverride = getManifest().assetUrlOverride;\n  if (assetUrlOverride) {\n    var _uri = path.join(assetUrlOverride, hash);\n    return {\n      uri: resolveUri(_uri),\n      hash: hash\n    };\n  }\n  var fileScale = scale === 1 ? '' : \"@\".concat(scale, \"x\");\n  var fileExtension = meta.type ? \".\".concat(encodeURIComponent(meta.type)) : '';\n  var suffix = \"/\".concat(encodeURIComponent(meta.name)).concat(fileScale).concat(fileExtension, \"?platform=\").concat(encodeURIComponent(Platform.OS), \"&hash=\").concat(encodeURIComponent(meta.hash));\n  if (/^https?:\\/\\//.test(meta.httpServerLocation)) {\n    var _uri2 = meta.httpServerLocation + suffix;\n    return {\n      uri: _uri2,\n      hash: hash\n    };\n  }\n  var manifest2 = getManifest2();\n  if (manifest2 !== null && manifest2 !== void 0 && (_manifest2$extra = manifest2.extra) !== null && _manifest2$extra !== void 0 && (_manifest2$extra = _manifest2$extra.expoGo) !== null && _manifest2$extra !== void 0 && _manifest2$extra.developer) {\n    var baseUrl = new URL(\"http://\".concat(manifest2.extra.expoGo.debuggerHost));\n    baseUrl.set('pathname', meta.httpServerLocation + suffix);\n    return {\n      uri: baseUrl.href,\n      hash: hash\n    };\n  }\n  if (getManifest().developer) {\n    var _baseUrl = new URL(getManifest().bundleUrl);\n    _baseUrl.set('pathname', meta.httpServerLocation + suffix);\n    return {\n      uri: _baseUrl.href,\n      hash: hash\n    };\n  }\n  return {\n    uri: \"https://classic-assets.eascdn.net/~assets/\".concat(encodeURIComponent(hash)),\n    hash: hash\n  };\n}\nexport function resolveUri(uri) {\n  if (!manifestBaseUrl) {\n    return uri;\n  }\n  var _URL = new URL(uri),\n    protocol = _URL.protocol;\n  if (protocol !== '') {\n    return uri;\n  }\n  var baseUrl = new URL(manifestBaseUrl);\n  var resolvedPath = uri.startsWith('/') ? uri : path.join(baseUrl.pathname, uri);\n  baseUrl.set('pathname', resolvedPath);\n  return baseUrl.href;\n}","map":{"version":3,"names":["Platform","path","PixelRatio","URL","AssetSourceResolver","getManifest","getManifest2","manifestBaseUrl","assetMapOverride","selectAssetSource","meta","_manifest2$extra","hasOwnProperty","hash","_objectSpread","scale","pickScale","scales","get","index","findIndex","s","fileHashes","uri","fileUris","resolveUri","assetUrlOverride","_uri","join","fileScale","concat","fileExtension","type","encodeURIComponent","suffix","name","OS","test","httpServerLocation","_uri2","manifest2","extra","expoGo","developer","baseUrl","debuggerHost","set","href","_baseUrl","bundleUrl","_URL","protocol","resolvedPath","startsWith","pathname"],"sources":["C:\\Users\\migue\\TravelQuest\\node_modules\\expo-asset\\src\\AssetSources.ts"],"sourcesContent":["import { Platform } from 'expo-modules-core';\nimport path from 'path-browserify';\nimport { PixelRatio } from 'react-native';\nimport { PackagerAsset } from 'react-native/Libraries/Image/AssetRegistry';\nimport URL from 'url-parse';\n\nimport AssetSourceResolver from './AssetSourceResolver';\nimport { getManifest, getManifest2, manifestBaseUrl } from './PlatformUtils';\n\n// @docsMissing\nexport type AssetMetadata = Pick<\n  PackagerAsset,\n  'httpServerLocation' | 'name' | 'hash' | 'type' | 'scales' | 'width' | 'height'\n> & {\n  uri?: string;\n  fileHashes?: string[];\n  fileUris?: string[];\n};\n\nexport type AssetSource = {\n  uri: string;\n  hash: string;\n};\n\n// Fast lookup check if asset map has any overrides in the manifest\nconst assetMapOverride = getManifest().assetMapOverride;\n\n/**\n * Selects the best file for the given asset (ex: choosing the best scale for images) and returns\n * a { uri, hash } pair for the specific asset file.\n *\n * If the asset isn't an image with multiple scales, the first file is selected.\n */\nexport function selectAssetSource(meta: AssetMetadata): AssetSource {\n  // Override with the asset map in manifest if available\n  if (assetMapOverride && assetMapOverride.hasOwnProperty(meta.hash)) {\n    meta = { ...meta, ...assetMapOverride[meta.hash] };\n  }\n\n  // This logic is based on that of AssetSourceResolver, with additional support for file hashes and\n  // explicitly provided URIs\n  const scale = AssetSourceResolver.pickScale(meta.scales, PixelRatio.get());\n  const index = meta.scales.findIndex((s) => s === scale);\n  const hash = meta.fileHashes ? meta.fileHashes[index] || meta.fileHashes[0] : meta.hash;\n\n  // Allow asset processors to directly provide the URL to load\n  const uri = meta.fileUris ? meta.fileUris[index] || meta.fileUris[0] : meta.uri;\n  if (uri) {\n    return { uri: resolveUri(uri), hash };\n  }\n\n  // Check if the assetUrl was overridden in the manifest\n  const assetUrlOverride = getManifest().assetUrlOverride;\n  if (assetUrlOverride) {\n    const uri = path.join(assetUrlOverride, hash);\n    return { uri: resolveUri(uri), hash };\n  }\n\n  const fileScale = scale === 1 ? '' : `@${scale}x`;\n  const fileExtension = meta.type ? `.${encodeURIComponent(meta.type)}` : '';\n  const suffix = `/${encodeURIComponent(\n    meta.name\n  )}${fileScale}${fileExtension}?platform=${encodeURIComponent(\n    Platform.OS\n  )}&hash=${encodeURIComponent(meta.hash)}`;\n\n  // For assets with a specified absolute URL, we use the existing origin instead of prepending the\n  // development server or production CDN URL origin\n  if (/^https?:\\/\\//.test(meta.httpServerLocation)) {\n    const uri = meta.httpServerLocation + suffix;\n    return { uri, hash };\n  }\n\n  // For assets during development using manifest2, we use the development server's URL origin\n  const manifest2 = getManifest2();\n\n  if (manifest2?.extra?.expoGo?.developer) {\n    const baseUrl = new URL(`http://${manifest2.extra.expoGo.debuggerHost}`);\n    baseUrl.set('pathname', meta.httpServerLocation + suffix);\n\n    return {\n      uri: baseUrl.href,\n      hash,\n    };\n  }\n\n  // For assets during development, we use the development server's URL origin\n  if (getManifest().developer) {\n    const baseUrl = new URL(getManifest().bundleUrl);\n    baseUrl.set('pathname', meta.httpServerLocation + suffix);\n    return { uri: baseUrl.href, hash };\n  }\n\n  // Production CDN URIs are based on each asset file hash\n  return {\n    uri: `https://classic-assets.eascdn.net/~assets/${encodeURIComponent(hash)}`,\n    hash,\n  };\n}\n\n/**\n * Resolves the given URI to an absolute URI. If the given URI is already an absolute URI, it is\n * simply returned. Otherwise, if it is a relative URI, it is resolved relative to the manifest's\n * base URI.\n */\nexport function resolveUri(uri: string): string {\n  if (!manifestBaseUrl) {\n    return uri;\n  }\n\n  const { protocol } = new URL(uri);\n  if (protocol !== '') {\n    return uri;\n  }\n\n  const baseUrl = new URL(manifestBaseUrl);\n  const resolvedPath = uri.startsWith('/') ? uri : path.join(baseUrl.pathname, uri);\n  baseUrl.set('pathname', resolvedPath);\n  return baseUrl.href;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}